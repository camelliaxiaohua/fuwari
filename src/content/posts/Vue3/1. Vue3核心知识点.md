---
title: Vue3核心知识点
category: 前端
tags:
  - vue3
  - 前端框架
published: 2026-01-04
updated: 2026-01-04
draft: false
---
---
## 1. 创建Vue工程

`vite` 是新一代前端构建工具，官网地址：[https://vitejs.cn](https://vitejs.cn/)，`vite`的优势如下：
- 轻量快速的热重载（`HMR`），能实现极速的服务启动。
- 对 `TypeScript`、`JSX`、`CSS` 等支持开箱即用。
- 真正的按需编译，不再等待整个应用编译完成。
- `webpack`构建 与 `vite`构建对比图如下：
<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/1683167182037-71c78210-8217-4e7d-9a83-e463035efbbe.png" alt="webpack构建" title="webpack构建" style="zoom:20%;box-shadow:0 0 10px black" />	<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/1683167204081-582dc237-72bc-499e-9589-2cdfd452e62f.png" alt="vite构建" title="vite构建" style="zoom: 20%;box-shadow:0 0 10px black" />
具体操作如下（[官方文档](https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application)）
```markdown
1. 创建命令
npm create vue@latest
---
2. 配置项目名称
√ Project name: 项目名称
---
3. 是否添加TypeScript支持
√ Add TypeScript?  Yes
---
3. 是否添加JSX支持
√ Add JSX Support?  No
---
4. 是否添加路由环境
√ Add Vue Router for Single Page Application development?  No
---
5. 是否添加pinia环境
√ Add Pinia for state management?  No
---
6. 是否添加单元测试
√ Add Vitest for Unit Testing?  No
7. 是否添加端到端测试方案
√ Add an End-to-End Testing Solution? » No
---
8. 是否添加ESLint语法检查
√ Add ESLint for code quality?  Yes
---
9. 是否添加Prettiert代码格式化
√ Add Prettier for code formatting?  No
```

**总结：**

- `Vite` 项目中，`index.html` 是项目的入口文件，在项目最外层。
- 加载`index.html`后，`Vite` 解析 `<script type="module" src="xxx">` 指向的`JavaScript`。
- `Vue3`**中是通过 **`createApp` 函数创建一个应用实例。

```ts
import './assets/main.css'
import { createApp } from 'vue' // 创建应用 （花盆）
import App from './App.vue' // 组件（相当于花的根）
createApp(App).mount('#app')
```
- `createApp(App)` 会创建一个 Vue 应用，`App` 是项目的**根组件**，也就是整个 Vue 应用的起点。
- `App` 通常是一个 Vue 组件，包含了数据、模板、方法等。`
- `.mount('#app')` 这一步把 Vue 应用挂载到 **`index.html`** 文件中的指定 DOM 元素上，`#app` 是 **id** 选择器，表示挂载的位置。

## 2. Vue3核心语法

#### 2.1 `Options API` 与 `Composition API`

`Options`类型的 `API`，数据、方法、计算属性等，是分散在：`data`、`methods`、`computed`中的，若想新增或者修改一个需求，就需要分别修改：`data`、`methods`、`computed`，不便于维护和复用。
<div style="display:flex; gap:16px;">
  <img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/1696662197101-55d2b251-f6e5-47f4-b3f1-d8531bbf9279.gif"
       style="height:300px;border-radius:20px" />
  <img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/1696662200734-1bad8249-d7a2-423e-a3c3-ab4c110628be.gif"
       style="height:300px;border-radius:20px" />
</div>

而Composition API就是把相关逻辑写在一起，而不是按 API 类型拆分。


<div style="display:flex; gap:16px;">
  <img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/1696662249851-db6403a1-acb5-481a-88e0-e1e34d2ef53a.gif"
       style="height:300px;border-radius:10px" />
  <img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/1696662256560-7239b9f9-a770-43c1-9386-6cc12ef1e9c0.gif"
       style="height:300px;border-radius:10px" />
</div>

### 2.2. `setup`实现`Composition API`

`setup`是`Vue3`中一个新的配置项，值是一个函数，它是`Composition API` **表演的舞台**，组件中所用到的：数据、方法、计算属性、监视......等等，均配置在`setup`中。

特点如下：

- `setup` 函数返回的对象中的内容，可直接在模板中使用；
  
- `setup` 中访问 `this` 是 `undefined`，不可使用；
  
- `setup` 函数会在 `beforeCreate` 之前调用，它是“领先”所有钩子执行的。

#### 2.2.1. `setup` 的基本语法

```ts
<template>
  <div class="person">
    <!-- 模板中可以直接使用 setup 返回的数据 -->
    <h2>姓名：{{ name }}</h2>
    <h2>年龄：{{ age }}</h2>

    <!-- 事件绑定，调用 setup 中返回的方法 -->
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">年龄+1</button>
    <button @click="showTel">点我查看联系方式</button>
  </div>
</template>

<script lang="ts">
export default {
  name: 'Person',

  /**
   * setup 是 Vue 3 Composition API 的入口函数
   * 在组件创建之前执行
   */
  setup() {
    // 这里定义的数据，原本在 Vue2 中写在 data() 里
    // ⚠ 注意：此时的 name、age、tel 都是普通变量，不是响应式数据。
    let name = '张三'
    let age = 18
    let tel = '13888888888'


    // 这里的方法，原本在 Vue2 中写在 methods 里
    function changeName() {
      name = 'zhang-san'
    }

    function changeAge() {
      age += 1
    }

    function showTel() {
      alert(tel)
    }

    // 暴露给模板使用
    return {
      name,
      age,
      tel,
      changeName,
      changeAge,
      showTel
    }
  }
}
</script>
```

#### 2.2.2. `setup`与`Options API`的关系

Vue2 风格的配置项（`data`、`methods`、`computed` 等）,可以访问 `setup` 中返回的属性和方法。

**示例：**

```js
export default {
  setup() {
    const msg = 'hello'
    function sayHi() {
      console.log('hi')
    }
    return { msg, sayHi }
  },

  mounted() {
    // ✅ 可以访问 setup 返回的内容
    console.log(this.msg)
    this.sayHi()
  }
}
```

> 原因：`setup` 返回的数据会被 **合并到组件实例上**，供 Options API 使用。

但在 `setup` 中，访问不到 `data`、`methods`、`computed` 等 Options API 配置。

**示例：**

```js
export default {
  data() {
    return {
      count: 10
    }
  },

  setup() {
    console.log(this.count) // ❌ undefined
  }
}
```

- `setup` 执行时：
    
    - 组件实例 **还没有创建**
        
    - `this` 是 `undefined`
        
- 所以：
    
    - 访问不到 `data`
        
    - 访问不到 `methods`
        
    - 访问不到 `computed`
        
    - 访问不到 `this`

#### 2.2.3. `setup`语法糖

`<script setup>` 是 Vue 3 为 **Composition API** 提供的 **编译期语法糖**，用于**简化 `setup()` 的写法**，不需要手动 **return**。

- 传统写法

```ts
<script>
import { ref } from 'vue'

export default {
  setup() {
    const count = ref(0)

    const add = () => {
      count.value++
    }

    return {
      count,
      add
    }
  }
}
</script>
```

- `setup` 语法糖写法

```ts
<script setup>
import { ref } from 'vue'

const count = ref(0)

const add = () => {
  count.value++
}
</script>
```

#### 2.2.4. 组件命名

在 Vue 3 中使用：

```ts
<script setup>
```

- 无法直接声明组件 `name`

**原始写法：**

```ts
<script setup>
</script>

<script>
export default {
  name: 'Person'
}
</script>
```

**Vite插件扩展：**

- 安装插件
	
```shell
npm i vite-plugin-vue-setup-extend -D
```

- 在 `vite.config.ts` 中注册插件
	
```ts
import { defineConfig } from 'vite'
import VueSetupExtend from 'vite-plugin-vue-setup-extend'

export default defineConfig({
  plugins: [VueSetupExtend()]
})
```

- 在 `<script setup>` 中直接声明 name

```ts
<script setup lang="ts" name="Person">
</script>
```

- 插件会在 **编译阶段** 自动生成

```ts
export default {
  name: 'Person'
}
```

**defineOptions：**

```ts
<script setup lang="ts">
defineOptions({
  name: 'Person'
})
</script>
```

> Vue 3.3 开始，官方提供：`defineOptions`。

### 2.3. 响应式数据

#### 2.3.1. `ref`创建基本类型的响应式数据

`ref`是Vue 3中用于**创建响应式数据** 的 API，用来让 **基本类型数据**（`number / string / boolean` 等）也能拥有 **响应式能力**。
##### 2.3.1.1. 基本用法

1. 创建响应式数据
	
```ts
import { ref } from 'vue'
const count = ref(0)
```

2. 读取和修改值
	
```ts
count.value       // 读取
count.value++     // 修改
```

> **`.value` 是必须的**;

3. 模板中使用（自动解包）
	
```ts
<p>{{ count }}</p>
<button @click="count++">+</button>
```

> 模板中 **不需要 `.value`**。

#### 2.3.2. `reactive`创建对象类型的响应式数据

`reactive` 用于 **创建响应式对象**，通过 **Proxy** 对对象进行代理，实现数据变化自动更新视图。

> **专门用于对象 / 数组 / Map / Set 等引用类型**

##### 2.3.2.1. 基本用法

1. 创建响应式对象
	
```ts
import { reactive } from 'vue'

const state = reactive({
  count: 0,
  user: {
    name: 'Alice'
  }
})
```

2. 读取与修改
	
```ts
state.count++
state.user.name = 'Bob'
```

> 不需要 `.value`，直接操作属性。

##### 2.3.2.2. 核心特点与局限

`reactive` 具有**深度响应式**的特点，当对象中存在嵌套结构时，即使修改的是深层属性（如 `state.user.name = 'Tom'`），依然可以触发视图更新。需要注意的是，`reactive` **只能接收对象类型的数据**，不能用于基本类型（如 `reactive(1)`、`reactive('hello')` 均无效），其适用范围包括 `Object`、`Array`、`Map` 和 `Set` 等引用类型。`reactive` 基于 **Proxy** 实现，这是 Vue 3 相比 Vue 2 的核心优势之一，它可以监听属性的新增和删除，性能更好，也不再需要使用 `Vue.set`。

同时，`reactive` 也存在一定的局限性：**不能直接替换整个响应式对象**，例如 `state = { count: 10 }` 会导致响应式失效，正确的做法应是修改对象内部属性（如 `state.count = 10`）。此外，**对 reactive 对象进行解构会丢失响应式**，例如 `const { count } = state` 是错误的，解决方案是配合 `toRefs` 使用：`const { count } = toRefs(state)`，以保持属性的响应式能力。

#### 2.3.3. `ref`创建对象类型的响应式数据

在Vue 3中，`ref`不仅可以用于基本类型数据，也可以用于**对象类型数据**。当使用 `ref` 包裹一个对象时，Vue内部会自动将该对象转换为**深度响应式对象**（本质上等价于对对象使用 `reactive`），但最外层仍然是一个`ref`，因此在 JavaScript 中访问或修改时必须通过`.value`。

```js
import { ref } from 'vue'
const user = ref({
  name: 'Tom',
  age: 18
})
```

访问和修改对象属性时，需要先通过`.value` 取出对象：

```js
user.value.age++
user.value.name = 'Jerry'
```

由于对象内部已经是响应式的，修改其任意属性都会触发视图更新。在模板中使用时，Vue 会对 `ref` 进行 **自动解包（unref）**，因此可以直接写成：

```html
<p>{{ user.name }} - {{ user.age }}</p>
```

无需使用 `.value`。

需要注意的是，虽然 `ref` 包裹对象在使用上类似 `reactive`，但二者仍有区别：`ref` 更适合用于**需要整体替换对象**或**需要解构仍保持响应式**的场景，而 `reactive` 更适合表示结构稳定的状态对象。

#### 2.3.4. `ref`与`reactive`对象整体替换与响应式


> [!info] Info
> 1. `reactive` **不能通过重新赋值来替换整个对象**，否则会失去响应式；
> 	
> 2. 即使重新调用 `reactive()` 包裹新对象，**也仍然不行**；
> 	
> 3. `ref` **可以通过 `.value` 直接整体替换对象**，且不会丢失响应式。

```js
let state = reactive({ user: { name: 'Tom', age: 18 } })

state = { user: { name: 'Jerry', age: 20 } }              // ❌ 失去响应式
state = reactive({ user: { name: 'Jerry', age: 20 } })    // ❌ 依然失去响应式

```

**原因说明：**

- `reactive` 返回的是一个 **Proxy 对象**；
    
- Vue 的模板和依赖追踪 **绑定在第一次创建的 Proxy 上**；
    
- 后续只是修改了 JS 变量的指向；
    
- Vue **不会重新建立依赖关系**。
    

> 即：响应式系统仍然监听的是“旧的 Proxy”

##### 2.3.4.1 `reactive`的正确整体替换方式

```js
Object.assign(state, {
  user: {
    name: 'Jerry',
    age: 20
  }
})

```

- 不改变对象引用
    
- 只修改对象内部属性
    
- 响应式能力不丢失
    

##### 2.3.4.2. `ref`的正确整体替换方式

```js
state.value = {
  user: {
    name: 'Jerry',
    age: 20
  }
}
```

> 通过 `.value` 重新赋值整个对象

- `ref` 的响应式**绑定在 `.value` 上**
    
- 给 `.value` 重新赋一个 **新对象**
    
    - 不会丢失响应式
        
    - Vue 会对新对象重新做响应式处理
        
- 与 `reactive` 不同，`ref` **天然支持对象整体替换**
    
