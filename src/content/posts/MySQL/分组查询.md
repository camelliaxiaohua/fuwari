---
title: 分组查询
category: MySQL
tags:
  - MySQL应用
published: 2022-05-20
updated: 2022-05-20
---
---

`GROUP BY` 是用于对查询结果进行分组的子句，通常与聚合函数（如 `SUM`、`COUNT`、`AVG`、`MAX`、`MIN` 等）结合使用，以便对每个分组的数据进行统计或计算。

为 `GROUP BY` 的列创建索引可以加速分组操作，但应避免在大表上使用复杂的多列组。

### 1. 基本语法

+ **数据分组**：将相同值的行归为一组。
+ **聚合计算**：对每个分组应用聚合函数（如求和、计数、平均值等）。

```sql
SELECT column1, aggregate_function(column2)
FROM table_name
WHERE condition
GROUP BY column1;
```

> `GROUP BY` 将数据按指定列（`column1`）的值分组。
> 每个分组返回一行结果，通常结合聚合函数对分组后的数据计算。


### 2. HAVING 子句

+ `WHERE` 用于过滤原始数据，而 `HAVING` 用于过滤分组后的结果。

```sql
SELECT department, AVG(salary) AS avg_salary
FROM employees
GROUP BY department
HAVING avg_salary > 5000;
```

> 筛选平均工资大于 5000 的部门

### 3. 注意事项

+ **错误用法**

```sql
-- 错误示例：SELECT 包含非聚合列且未在 GROUP BY 中声明
SELECT name, department, AVG(salary)
FROM employees
GROUP BY department;
```

> `name` 不在 `GROUP BY` 中，且未使用聚合函数，可能导致多值不确定性问题。所以大部分数据库会报错：**“name not in GROUP BY”**。  有些宽松的数据库（比如 MySQL 的 `ONLY_FULL_GROUP_BY` 关掉时）会“随便挑一个 name”，但这是**非标准行为，结果不可控**。


**当你使用 `GROUP BY` 时，查询中的每一列要么需要被聚合，要么需要出现在 `GROUP BY` 子句中。**

+ **正确做法**

```sql
SELECT 
	group_concat(name) as name,
	department, 
	MAX(salary) AS max_salary
FROM employees
GROUP BY department;
```

> `SELECT` 中的非聚合列必须在 `GROUP BY` 中声明，使用聚合函数处理非分组列。


### 4. WITH ROLLUP

```sql
SELECT department, job_title, SUM(salary)
FROM employees
GROUP BY department, job_title WITH ROLLUP;
```

> 生成分组的小计和总计（类似多维分析），结果会包含按 `department` 的小计，以及最终的总计。



## `HAVING` 子句
在 SQL 中，`HAVING` 子句用于对 `GROUP BY` 分组后的结果进行筛选。它与 `WHERE` 子句类似，但核心区别在于：

+ `WHERE`：在数据**分组前**过滤原始数据（操作对象是表中的原始行）。
+ `HAVING`：在数据**分组后**过滤聚合结果（操作对象是分组后的聚合值）。

### 核心语法
```sql
SELECT column1, aggregate_function(column2)
FROM table_name
WHERE condition   -- 分组前的筛选（可选）
GROUP BY column1
HAVING condition; -- 分组后的筛选
```

### **核心作用**
+ 对 `GROUP BY` 分组后的结果进行条件过滤。
+ **只能用于分组后的聚合值**（如 `SUM()`、`AVG()`、`COUNT()` 等）。

### **使用场景示例**
+ **错误示例**

```sql
-- 错误：WHERE 中使用了聚合函数
SELECT department, AVG(salary)
FROM employees
WHERE AVG(salary) > 5000  -- 此处会报错！
GROUP BY department;
```

+ **正确写法**

```sql
-- 正确：HAVING 中筛选聚合结果
SELECT department, AVG(salary)
FROM employees
GROUP BY department
HAVING AVG(salary) > 5000;
```

+ **筛选分组后的聚合值**

统计部门平均工资大于 5000 的部门。

```sql
SELECT department, AVG(salary) AS avg_salary
FROM employees
GROUP BY department
HAVING avg_salary > 5000;
```

> `HAVING` 筛选的是分组后的 `avg_salary`（聚合结果）。
>

+ **结合聚合函数和逻辑条件**

统计订单总金额超过 1000 且订单数大于 3 的客户。

```sql
SELECT customer_id, 
       SUM(order_amount) AS total_amount,
       COUNT(*) AS order_count
FROM orders
GROUP BY customer_id
HAVING total_amount > 1000 AND order_count > 3;
```

+ **与 WHERE 联用（先过滤原始数据，再过滤分组结果）**

```sql
-- 统计2023年销售额超过10万的销售员
SELECT salesperson_id, SUM(sales) AS total_sales
FROM sales
WHERE YEAR(order_date) = 2023  -- 先筛选2023年的数据
GROUP BY salesperson_id
HAVING total_sales > 100000;   -- 再筛选总销售额>10万
```

### **注意事项**
+ **在 HAVING 中引用非聚合列**

```sql
-- 错误：city 不在 GROUP BY 中，且未用聚合函数
SELECT country, city, AVG(income)
FROM cities
GROUP BY country
HAVING city = 'Paris';  -- 此处会报错！
```

+ **混淆 WHERE 和 HAVING 的执行顺序**

```sql
-- 错误逻辑：试图用 WHERE 筛选聚合结果
SELECT department, AVG(salary)
FROM employees
WHERE AVG(salary) > 5000  -- WHERE 无法处理聚合值！
GROUP BY department;
```

### **性能优化**
**先过滤，后分组**：尽量先用 `WHERE` 缩小数据集，再用 `HAVING` 过滤分组结果。

**索引优化**：对 `GROUP BY` 的列建立索引可加速分组操作。