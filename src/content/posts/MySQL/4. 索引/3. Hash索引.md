---
title: Hash索引
category: MySQL
tags:
  - MySQL进阶
  - MySQL原理
  - MySQL索引结构
published: 2023-03-18
updated: 2023-03-18
draft: false
---
---
**Hash数据索引** 是一种使用哈希表数据结构来构建的索引。它的核心思想是：**通过一个哈希函数，将索引键（例如数据库表中的某列值）直接转换成一个固定长度的哈希值，这个哈希值对应着数据存储的位置（如内存地址或磁盘页）。**

可以把它想象成一个超级高效的“目录”或“标签系统”：

*   **输入（Key）**： 你要查找的值（例如，用户ID `101`，商品名称 `"Apple"`）。
*   **哈希函数（Hash Function）**： 一个“魔法机器”，它吃掉输入，吐出一个固定的、看似随机的数字（哈希值）。例如 `hash(101) -> 3`, `hash("Apple") -> 7`。
*   **输出（Value）**： 这个哈希值直接告诉你数据存储在哪个“桶”（Bucket）或“槽位”（Slot）里。你可以直接去那个位置找到数据。

### 1. 工作原理

1.  **建立索引**：
		
    *   为需要索引的列（如 `user_id`）创建一个哈希索引。
		
    *   系统会初始化一个由多个“桶”组成的数组。
		
    *   对于表中的每一行，提取其索引键（如 `user_id = 101`），通过哈希函数计算其哈希值（如 `hash(101) = 3`）。
		
    *   将该行的指针（或直接存储数据）放入第3个桶中。

2.  **查询数据（等值查询）**：
		
    *   当你要查找 `user_id = 101` 的用户时，系统再次计算 `hash(101) = 3`。
		
    *   然后直接跳转到第3个桶中寻找数据。
		
    *   理想情况下，这个操作的时间复杂度是 **O(1)**，即常数时间复杂度，与数据总量无关。

3.  **处理哈希冲突**：
		
    *   不同的键有可能计算出相同的哈希值（例如 `hash(“John”)` 和 `hash(“Jane”)` 都等于5），这称为“哈希冲突”。
		
    *   常见的解决方法有：
		
        *   **链地址法**： 每个桶不是一个单独的位置，而是一个链表（或列表）。所有哈希到同一位置的键值对都会被放入这个链表中。查找时，在链表中进行小范围的线性搜索。
		
        *   **开放地址法**： 如果目标桶已被占用，就按照某种规则（如线性探测、二次探测）寻找下一个空闲的桶。

### 2. 优点

*   **极快的等值查询速度**： 这是Hash索引最大的优势。对于 `=`、`IN()` 这类精确匹配的查询，速度无与伦比，几乎是瞬间完成。
	
*   **时间复杂度低**： 平均情况下，插入、删除、查找操作都是 O(1)。

### 3. 缺点

*   **不支持范围查询**： 这是它最致命的缺点。由于哈希函数将键“随机”地映射到不同的桶中，它**无法**处理 `WHERE age > 18`、`BETWEEN ... AND ...`、`ORDER BY` 等需要顺序扫描的查询。这些操作需要遍历所有桶，效率极低。
	
*   **不支持前缀匹配**： 同样因为哈希的“随机性”，它**无法**进行 `LIKE ‘abc%’` 这样的模糊查询。
	
*   **排序效率低**： 因为数据本身不是按索引键的顺序存储的，所以对结果集排序需要额外的开销。
	
*   **哈希冲突**： 如果哈希函数选择不当或桶的数量太少，会导致冲突频繁，性能退化为 O(n)（即退化成在链表中遍历）。
	
*   **全表扫描**： 当需要扫描大部分数据时，Hash索引可能不如B+Tree索引高效。

### 4. 应用场景

Hash索引最适合用于那些**只有等值查询，没有范围查询和排序需求**的场景。

*   **内存数据库**： 如 Redis，其核心数据结构就是哈希表，非常适合存储键值对。
	
*   **数据库的哈希连接**： 在数据库执行表连接操作时，常使用其中一张表在内存中构建哈希表来加速连接过程。
	
*   **数据库引擎中的特定索引**：
	
    *   **MySQL的Memory存储引擎**： 默认使用Hash索引。
		
    *   **InnoDB存储引擎的自适应哈希索引**： 当InnoDB发现某些索引值被非常频繁地用等值查询访问时，它会在内存中为这些页自动创建一个Hash索引，以加速访问。这是对B+Tree索引的一个补充优化。

### 5. Hash索引 vs. B+Tree索引

这是一个非常经典的对比：

| 特性 | Hash索引 | B+Tree索引 |
| :--- | :--- | :--- |
| **查询类型** | **仅支持**等值查询（=, IN） | **支持**等值、范围查询（>, <, BETWEEN）、排序（ORDER BY） |
| **查询速度** | 等值查询 **极快** (O(1)) | 等值查询 **很快** (O(log n))，范围查询也很快 |
| **排序** | 不支持 | 天然支持，因为数据在叶子节点上是顺序存储的 |
| **磁盘I/O** | 不适合磁盘存储，因为访问是随机的 | 非常适合磁盘存储，叶子节点形成链表，顺序I/O效率高 |
| **适用场景** | 内存表、缓存、等值查询密集型 | 通用型，适用于绝大多数数据库应用场景 |

### 总结

**Hash数据索引** 是一把锋利的“手术刀”，在**精确匹配查询**这个特定任务上，它的性能是顶级的。然而，它的局限性（不支持范围查询和排序）使其无法成为通用数据库索引的“瑞士军刀”。在实际的数据库系统（如MySQL的InnoDB、PostgreSQL）中，**B+Tree索引**因其全面的功能（支持等值、范围、排序）和出色的磁盘I/O性能，成为了默认和最主要的索引类型。Hash索引通常作为特定场景下的性能优化手段存在。