---
title: 6. 线程同步
category: 并发
tags:
  - 线程同步
---
---

**<font style="color:#000000;">当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</font>**

这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。

```java
// 多线程
public class Main {
    public static void main(String[] args) throws Exception {
        var add = new AddThread();
        var dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    }
}

class Counter {
    public static int count = 0;
}

class AddThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) { Counter.count += 1; }
    }
}

class DecThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) { Counter.count -= 1; }
    }
}
```

上面的代码很简单，两个线程同时对一个`int`变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。

这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。

例如，对于语句：

```plain
n = n + 1;
```

看上去是一行语句，实际上对应了3条指令：

```plain
ILOAD
IADD
ISTORE
```

我们假设`n`的值是`100`，如果两个线程同时执行`n = n + 1`，得到的结果很可能不是`102`，而是`101`，原因在于：

```plain
┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │ILOAD (100)  │
    │             │ILOAD (100)
    │             │IADD
    │             │ISTORE (101)
    │IADD         │
    │ISTORE (101) │
    ▼             ▼
```

如果线程1在执行`ILOAD`后被操作系统中断，此刻如果线程2被调度执行，它执行`ILOAD`后获取的值仍然是`100`，最终结果被两个线程的`ISTORE`写入后变成了`101`，而不是期待的`102`。

这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：**<font style="color:#000000;">即某一个线程执行时，其他线程必须等待。</font>**

```plain
┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │-- lock --   │
    │ILOAD (100)  │
    │IADD         │
    │ISTORE (101) │
    │-- unlock -- │
    │             │-- lock --
    │             │ILOAD (101)
    │             │IADD
    │             │ISTORE (102)
    │             │-- unlock --
    ▼             ▼
```

通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。**<font style="color:#000000;">这种加锁和解锁之间的代码块我们称之为</font>****<font style="color:rgb(36,91,219);">临界区</font>**（Critical Section），**任何时候临界区****<font style="color:rgb(36,91,219);">最多</font>****只有****<font style="color:rgb(36,91,219);">一个线程</font>****能执行。**

****

## `**synchronized**`**锁**
显然，确保代码的原子性是通过加锁和解锁来实现的。在Java程序中，可以使用`**<font style="color:#74B602;">synchronized</font>**`关键字来对一个对象进行加锁：

```java
synchronized(lock) {
    n = n + 1;
}
```

`synchronized`保证了代码块在任意时刻最多只有一个线程能执行。我们把上面的代码用`synchronized`改写如下：

```java
// 多线程
public class Main {
    public static void main(String[] args) throws Exception {
        var add = new AddThread();
        var dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    }
}

class Counter {
    public static final Object lock = new Object();
    public static int count = 0;
}

class AddThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) {
            synchronized(Counter.lock) {
                Counter.count += 1;
            }
        }
    }
}

class DecThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) {
            synchronized(Counter.lock) {
                Counter.count -= 1;
            }
        }
    }
}
```

注意到代码：

```java
synchronized(Counter.lock) { // 获取锁
    ...
} // 释放锁
```

它表示用`Counter.lock`实例作为锁，两个线程在执行各自的`synchronized(Counter.lock) { ... }`代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在`synchronized`语句块结束会自动释放锁。这样一来，对`Counter.count`变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。

使用`synchronized`确实可以解决多线程同步访问共享变量的问题，但它也有缺点，比如会导致性能降低。_<u>这是因为</u>_`_<u>synchronized</u>_`_<u>代码块不能同时并发执行。加上加锁和解锁本身就需要耗费时间，所以</u>_`_<u>synchronized</u>_`_<u>在一定程度上会减慢程序的运行效率。</u>_

### `**synchronized**`**的使用**
1. 找出修改共享变量的线程代码块；
2. 选择一个共享实例作为锁；
3. 使用`synchronized(lockObject) { ... }`。

在使用`synchronized`的时候，不必担心抛出异常。因为无论是否有异常，都会在`synchronized`结束处正确释放锁：

```java
public void add(int m) {
synchronized (obj) {
    if (m < 0) {
        throw new RuntimeException();
    }
    this.value += m;
} // 无论有无异常，都会在此释放锁
}
```

#### **使用**`**synchronized**`**的误区**
1. **一个临界区对应多把锁（**`**<font style="background-color:#F5D480;">临界区<锁</font>**`**）**

```java
// 多线程
public class Main {
    public static void main(String[] args) throws Exception {
        var add = new AddThread();
        var dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    }
}

class Counter {
    public static final Object lock1 = new Object();
    public static final Object lock2 = new Object();
    public static int count = 0;
}

class AddThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) {
            synchronized(Counter.lock1) {
                Counter.count += 1;
            }
        }
    }
}

class DecThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) {
            synchronized(Counter.lock2) {
                Counter.count -= 1;
            }
        }
    }
```

结果并不是0，这是因为两个线程各自的`synchronized`锁住的_不是同一个对象_！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。

因此，使用`synchronized`的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。

2. **多个临界区对应一把锁（**`**<font style="background-color:#F5D480;">临界区>锁</font>**`**）**

```java
// 多线程
public class Main {
    public static void main(String[] args) throws Exception {
        var ts = new Thread[] { new AddStudentThread(), new DecStudentThread(), new AddTeacherThread(), new DecTeacherThread() };
        for (var t : ts) {
            t.start();
        }
        for (var t : ts) {
            t.join();
        }
        System.out.println(Counter.studentCount);
        System.out.println(Counter.teacherCount);
    }
}

class Counter {
    public static final Object lock = new Object();
    public static int studentCount = 0;
    public static int teacherCount = 0;
}

class AddStudentThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) {
            synchronized(Counter.lock) {
                Counter.studentCount += 1;
            }
        }
    }
}

class DecStudentThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) {
            synchronized(Counter.lock) {
                Counter.studentCount -= 1;
            }
        }
    }
}

class AddTeacherThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) {
            synchronized(Counter.lock) {
                Counter.teacherCount += 1;
            }
        }
    }
}

class DecTeacherThread extends Thread {
    public void run() {
        for (int i=0; i<10000; i++) {
            synchronized(Counter.lock) {
                Counter.teacherCount -= 1;
            }
        }
    }
}
```

上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是`Counter.lock`这一个对象，这就造成了原本可以并发执行的`Counter.studentCount += 1`和`Counter.teacherCount += 1`，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：`AddStudentThread`和`DecStudentThread`，`AddTeacherThread`和`DecTeacherThread`，组之间不存在竞争，因此，应该使用两个不同的锁。

即：`AddStudentThread`和`DecStudentThread`使用`lockStudent`锁：

```java
synchronized(Counter.lockStudent) {
    ...
}
```

`AddTeacherThread`和`DecTeacherThread`使用`lockTeacher`锁：

```java
synchronized(Counter.lockTeacher) {
    ...
}
```

3. **不可变对象无需同步**

:::color3
**<font style="background-color:rgba(255, 255, 255, 0);">如果多线程操作的是不可变对象，那么就不需要同步控制，因为它们不会改变对象的状态。</font>**

:::

```java
class Data {
    List<String> names;
    void set(String[] names) {
        this.names = List.of(names);
    }
    List<String> get() {
        return this.names;
    }
}
```

注意到`set()`方法内部创建了一个不可变`List`，这个`List`包含的对象也是不可变对象`String`，因此，整个`List<String>`对象都是不可变的，因此读写均无需同步。

分析变量是否能被多线程访问时，首先要理清概念，多线程同时执行的是方法。

对于下面这个例子：

```java
class Status {
    List<String> names;
    int x;
    int y;
    void set(String[] names, int n) {
        List<String> ns = List.of(names);
        this.names = ns;
        int step = n * 10;
        this.x += step;
        this.y += step;
    }
    StatusRecord get() {
        return new StatusRecord(this.names, this.x, this.y);
    }
}
```

如果有A、B两个线程，同时执行是指：

+ 可能同时执行set()；
+ 可能同时执行get()；
+ 可能A执行set()，同时B执行get()。

类的成员变量`names`、`x`、`y`显然能被多线程同时读写，但局部变量（包括方法参数）如果没有“逃逸”，那么只有当前线程可见。局部变量`step`仅在`set()`方法内部使用，因此每个线程同时执行set时都有一份独立的step存储在线程的栈上，互不影响，但是局部变量`ns`虽然每个线程也各有一份，但后续赋值后对其他线程就变成可见了。对`set()`方法同步时，如果要最小化`synchronized`代码块，可以改写如下：

```java
void set(String[] names, int n) {
    // 局部变量其他线程不可见:
    List<String> ns = List.of(names);
    int step = n * 10;
    synchronized(this) {
        this.names = ns;
        this.x += step;
        this.y += step;
    }
}
```

因此，深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。



## 同步方法
在Java编程中，`synchronized`关键字是实现线程同步的主要手段。正确地识别锁定对象对于保证线程安全至关重要。如果允许线程随意选择锁对象，可能会导致代码逻辑混乱并且破坏封装性。因此，将`synchronized`的使用逻辑封装在设计良好的方法或对象中，是一种更为稳妥的做法。

例如，我们编写一个计数器如下：

```java
public class Counter {
    private int count = 0;

    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }

    public void dec(int n) {
        synchronized(this) {
            count -= n;
        }
    }

    public int get() {
        return count;
    }
}
```

这样一来，线程调用`add()`、`dec()`方法时，它不必关心同步逻辑，因为`synchronized`代码块在`add()`、`dec()`方法内部。并且，我们注意到，`synchronized`锁住的对象是`this`，即当前实例，这又使得创建多个`Counter`实例的时候，它们之间互不影响，可以并发执行。 

```java
var c1 = Counter();
var c2 = Counter();

// 对c1进行操作的线程。
new Thread(() -> {
    c1.add();
}).start();

new Thread(() -> {
    c1.dec();
}).start();

// 对c2进行操作的线程。
new Thread(() -> {
    c2.add();
}).start();
new Thread(() -> {
    c2.dec();
}).start();
```

现在，对于`Counter`类，多线程可以正确调用。

+ 当一个类被设计成可以被多线程正确地访问时，我们称这个类为**“线程安全的”**，例如上述的`Counter`类。Java标准库中的`java.lang.StringBuffer`也是线程安全的。
+ 此外，有些不可变的类，比如String，Integer和LocalDate，它们的所有成员变量都是final的，多线程访问时只能进行读操作，不能写操作，因此这些类也是线程安全的。
+ 最后，像`Math`这样的类，它们只提供静态方法且没有成员变量，也都是线程安全的。

除了上述几种少数情况，大部分类，例如`ArrayList`，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么`ArrayList`是可以安全地在线程间共享的。

**<font style="background-color:rgb(254,234,210);">没有特殊说明时，一个类默认是非线程安全的。</font>**

### 同步实例方法
我们再观察`Counter`的代码：

```java
public class Counter {
    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }
    ...
}
```

当我们锁住的是`this`实例时，实际上可以用`synchronized`修饰这个方法。下面两种写法是等价的：

+ **在代码块上添加同步锁**

```java
public void add(int n) {
synchronized(this) { // 锁住this
    count += n;
} // 解锁
}
```

+ **在实例方法上添加同步锁**

```java
public synchronized void add(int n) { // 锁住this
    count += n;
} // 解锁
```

因此，用`synchronized`修饰的方法就是同步方法，它表示整个方法都必须用`this`实例加锁。

### 同步静态方法
我们再思考一下，如果对一个**静态方法**添加`**synchronized**`修饰符，它锁住的是哪个对象？

```java
public synchronized static void test(int n) {
    ...
}
```

对于`static`方法，是没有`this`实例的，因为`static`方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的`Class`实例，因此，对`static`方法添加`synchronized`，锁住的是该类的`Class`实例。上述`synchronized static`方法实际上相当于：

```java
public class Counter {
    public static void test(int n) {
        synchronized(Counter.class) {
            ...
        }
    }
}
```

我们再考察`Counter`的`get()`方法：

```java
public class Counter {
    private int count;

    public int get() {
        return count;
    }
    ...
}
```

它没有同步，因为读一个`int`变量不需要同步。

然而，如果我们把代码稍微改一下，返回一个包含两个`int`的对象：

```java
public class Counter {
    private int first;
    private int last;

    public Pair get() {
        Pair p = new Pair();
        p.first = first;
        p.last = last;
        return p;
    }
    ...
}
```

就必须要同步了。



## 死锁
### 可重入锁
**Java的synchronized锁是可重入锁。**

什么是可重入的锁？我们还是来看例子：

```java
public class Counter {
    private int count = 0;

    public synchronized void add(int n) {
        if (n < 0) {
            dec(-n);
        } else {
            count += n;
        }
    }

    public synchronized void dec(int n) { 
        count += n; 
    }
}
```

观察`synchronized`修饰的`add()`方法，一旦线程执行到`add()`方法内部，说明它已经获取了当前实例的`this`锁。如果传入的`n < 0`，将在`add()`方法内部调用`dec()`方法。由于`dec()`方法也需要获取`this`锁，现在问题来了：

对同一个线程，能否在获取到锁以后继续获取同一个锁？

答案是肯定的。`**<font style="background-color:#FBDFEF;">JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</font>**`

由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出`synchronized`块，记录-1，减到0的时候，才会真正释放锁。

### 死锁
`**<font style="background-color:#FBDFEF;">一个线程可以获取一个锁后，再继续获取另一个锁。</font>**`

```java
public void add(int m) { 
synchronized(lockA) { // 获得lockA的锁this.value += m;

    synchronized(lockB) { // 获得lockB的锁this.another += m;

    } // 释放lockB的锁 
} // 释放lockA的锁 
}

public void dec(int m) { 
    synchronized(lockB) { // 获得lockB的锁this.another -= m;

        synchronized(lockA) { // 获得lockA的锁this.value -= m;

        } // 释放lockA的锁 
    } // 释放lockB的锁 
}
```

在获取多个锁的时候，**<font style="color:rgb(143,149,158);">不同线程</font>**获取多个不同对象的锁可能导致死锁。

对于上述代码，线程1和线程2如果分别执行`add()`和`dec()`方法时：

> 线程1：进入`add()`，获得`lockA`；
>

> 线程2：进入`dec()`，获得`lockB`。
>

随后：

> 线程1：准备获得`lockB`，失败，等待中；
>

> 线程2：准备获得`lockA`，失败，等待中。
>

此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。

死锁发生后，**没有**任何机制能解除死锁，**<font style="color:rgb(143,149,158);">只能</font>**强制结束JVM进程。

因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。

### 避免死锁
:::danger
**为了避免死锁，一个有效的策略是确保线程在获取多个锁时，总是以相同的顺序来获取。这样可以减少锁之间的循环等待现象，从而避免死锁的发生。**

:::

即严格按照先获取`lockA`，再获取`lockB`的顺序，改写`dec()`方法如下：

```java
public void dec(int m) {
synchronized(lockA) { // 获得lockA的锁this.value -= m;
    synchronized(lockB) { // 获得lockB的锁this.another -= m;
    } // 释放lockB的锁
} // 释放lockA的锁
}
```



## `wait`和`notify`
在Java程序中，`synchronized`解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用`synchronized`加锁：

```java
class TaskQueue {
    Queue<String> queue = new LinkedList<>();

    public synchronized void addTask(String s) {
        this.queue.add(s);
    }
}
```

但是`synchronized`并没有解决多线程协调的问题。

仍然以上面的`TaskQueue`为例，我们再编写一个`getTask()`方法取出队列的第一个任务：

```java
class TaskQueue {
    Queue<String> queue = new LinkedList<>();

    public synchronized void addTask(String s) {
        this.queue.add(s);
    }

    public synchronized String getTask() {
        while (queue.isEmpty()) {
        }
        return queue.remove();
    }
}
```

上述代码看上去没有问题：`getTask()`内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，`while()`循环退出，就可以返回队列的元素了。

但实际上`while()`循环永远不会退出。因为线程在执行`while()`循环时，已经在`getTask()`入口获取了`this`锁，其他线程根本无法调用`addTask()`，因为`addTask()`执行条件也是获取`this`锁。

因此，执行上述代码，线程会在`getTask()`中因为死循环而100%占用CPU资源。

如果深入思考一下，我们想要的执行效果是：

+ 线程1可以调用`addTask()`不断往队列中添加任务；
+ 线程2可以调用`getTask()`从队列中获取任务。如果队列为空，则`getTask()`应该等待，直到队列中至少有一个任务时再返回。

因此，多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。

对于上述`TaskQueue`，我们先改造`getTask()`方法，在条件不满足时，线程进入等待状态：

```java
public synchronized String getTask() {
    while (queue.isEmpty()) {
        this.wait();
    }
    return queue.remove();
}
```

当一个线程执行到`getTask()`方法内部的`while`循环时，它必定已经获取到了`this`锁，此时，线程执行`while`条件判断，如果条件成立（队列为空），线程将执行`this.wait()`，进入等待状态。

:::color3
**关键在于：**`**wait()**`**方法需要在已获取的锁对象上调用。在这种情况下，获取的是this锁，所以应该调用**`**this.wait()**`**。**

:::

调用`wait()`方法后，线程进入等待状态，`wait()`方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，`wait()`方法才会返回，然后，继续执行下一条语句。

有些仔细的童鞋会指出：即使线程在`getTask()`内部等待，其他线程如果拿不到`this`锁，照样无法执行`addTask()`，肿么办？

:::color3
**这个问题的核心在于**`**wait()**`**方法的执行机制极其复杂。首先，它并非普通的Java方法，而是Object类中的一个本地方法，由JVM的C语言代码实现。其次，wait()方法必须在synchronized块内调用，因为在调用wait()时，线程会释放其所持有的锁，并在wait()方法结束后，线程会再次尝试获取该锁。**

:::

因此，只能在锁对象上调用`wait()`方法。因为在`getTask()`中，我们获得了`this`锁，因此，只能在`this`对象上调用`wait()`方法：

```java
public synchronized String getTask() {
    while (queue.isEmpty()) {
        this.wait();
    }
    return queue.remove();
}
```

当一个线程在`this.wait()`等待时，它就会释放`this`锁，从而使得其他线程能够在`addTask()`方法获得`this`锁。

现在我们面临第二个问题：如何让等待的线程被重新唤醒，然后从`wait()`方法返回？

答案是在相同的锁对象上调用`notify()`方法。我们修改`addTask()`如下：

```java
public synchronized void addTask(String s) {
    this.queue.add(s);
    this.notify(); // 唤醒在this锁等待的线程
}
```

注意到在往队列中添加了任务后，线程立刻对`this`锁对象调用`notify()`方法，这个方法会唤醒一个正在`this`锁等待的线程（就是在`getTask()`中位于`this.wait()`的线程），从而使得等待线程从`this.wait()`方法返回。

我们来看一个完整的例子：

```java
import java.util.*;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        var q = new TaskQueue();
        var ts = new ArrayList<Thread>();
        for (int i=0; i<5; i++) {
            var t = new Thread() {
                public void run() {
                    // 执行task
                    while (true) {
                        try {
                            String s = q.getTask();
                            System.out.println("execute task: " + s);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }
            };
            t.start();
            ts.add(t);
        }
        var add = new Thread(() -> {
            for (int i=0; i<10; i++) {
                // 放入task
                String s = "t-" + Math.random();
                System.out.println("add task: " + s);
                q.addTask(s);
                try { Thread.sleep(100); } catch(InterruptedException e) {}
            }
        });
        add.start();
        add.join();
        Thread.sleep(100);
        for (var t : ts) {
            t.interrupt();
        }
    }
}

class TaskQueue {
    Queue<String> queue = new LinkedList<>();

    public synchronized void addTask(String s) {
        this.queue.add(s);
        this.notifyAll();
    }

    public synchronized String getTask() throws InterruptedException {
        while (queue.isEmpty()) {
            this.wait();
        }
        return queue.remove();
    }
}
```

这个例子中，我们重点关注`addTask()`方法，内部调用了`this.notifyAll()`而不是`this.notify()`。

:::danger
**使用**`**notifyAll()**`**会唤醒所有正在此this锁上等待的线程，而notify()则只唤醒一个线程（哪一个取决于操作系统，具有随机性）。**

:::

这是因为可能有多个线程正在`getTask()`方法内部的`wait()`中等待，使用`notifyAll()`将一次性全部唤醒。通常来说，`notifyAll()`更安全。有些时候，如果我们的代码逻辑考虑不周，用`notify()`会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。

但是，注意到`wait()`方法返回时需要_**重新**_获得`this`锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行`addTask()`的线程结束此方法后，才能释放`this`锁，随后，这3个线程中只能有一个获取到`this`锁，剩下两个将继续等待。

再注意到我们在`while()`循环中调用`wait()`，而不是`if`语句。

```java
public synchronized String getTask() throws InterruptedException {
    if (queue.isEmpty()) {
        this.wait();
    }
    return queue.remove();
}
```

这种写法实际上是错误的，因为线程被唤醒时，需要再次获取`this`锁。多个线程被唤醒后，只有一个线程能获取`this`锁。此刻，该线程执行`queue.remove()`可以获取到队列的元素。然而，剩下的线程如果获取`this`锁后执行`queue.remove()`，此刻队列可能已经没有任何元素了。所以，要始终在`while`循环中`wait()`，并且每次被唤醒后拿到`this`锁就必须再次判断。

```java
while (queue.isEmpty()) {
    this.wait();
}
```



## `ReentrantLock`锁
从Java 5开始，引入了一个高级的处理并发的`**<font style="color:rgb(143,149,158);">java.util.concurrent</font>**`包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。

我们知道Java语言中直接提供了`synchronized`关键字来实现加锁，但这种锁不仅重，而且在获取时必须不断等待，缺乏其他尝试的机制。

`java.util.concurrent.locks`包提供的`ReentrantLock`用于替代`synchronized`加锁，我们来看一下传统的`synchronized`代码：

```java
public class Counter {
    private int count;

    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }
}
```

如果用`ReentrantLock`替代，可以把代码改造为。

```java
public class Counter {
    private final Lock lock = new ReentrantLock();
    private int count;

    public void add(int n) {
        lock.lock();
        try {
            count += n;
        } finally {
            lock.unlock();
        }
    }
}
```

因为`synchronized`是Java语言层面提供的语法，所以我们不需要考虑异常。**而**`**ReentrantLock**`**是Java代码实现的锁，我们就必须先获取锁，然后在**`**finally**`**中正确释放锁。**

:::danger
**正如其名，**`**ReentrantLock**`**是一个可重入的锁，它允许一个线程多次获得同一把锁，类似于**`**synchronized**`**。**

:::

和`synchronized`不同的是，`ReentrantLock`可以尝试获取锁：

```java
if (lock.tryLock(1, TimeUnit.SECONDS)) {
    try {
        ...
    } finally {
        lock.unlock();
    }
}
```

上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，`tryLock()`返回`false`。程序就可以做一些额外处理，而不是无限等待下去。

所以，使用`ReentrantLock`比直接使用`synchronized`更安全，线程在`tryLock()`失败的时候不会导致死锁。



## `Condition`
使用`ReentrantLock`比直接使用`synchronized`更安全，可以替代`synchronized`进行线程同步。

但是，`synchronized`可以配合`wait`和`notify`实现线程在条件不满足时等待，条件满足时唤醒，用`ReentrantLock`我们怎么编写`wait`和`notify`的功能呢？

答案是使用`Condition`对象来实现`wait`和`notify`的功能。

我们仍然以`TaskQueue`为例，把前面用`synchronized`实现的功能通过`ReentrantLock`和`Condition`来实现：

```java
class TaskQueue {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private Queue<String> queue = new LinkedList<>();

    public void addTask(String s) {
        lock.lock();
        try {
            queue.add(s);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public String getTask() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                condition.await();
            }
            return queue.remove();
        } finally {
            lock.unlock();
        }
    }
}
```

:::danger
**显然，在使用Condition时，必须通过Lock实例的**`**newCondition()**`**方法来获取Condition对象，以确保该Condition实例与Lock实例绑定。**

:::

`Condition`提供的`await()`、`signal()`、`signalAll()`原理和`synchronized`锁对象的`wait()`、`notify()`、`notifyAll()`是一致的，并且其行为也是一样的。

+ `**<font style="color:#74B602;">await()</font>**`会释放当前锁，进入等待状态；
+ `**<font style="color:#74B602;">signal()</font>**`会唤醒某个等待线程；
+ `**<font style="color:#74B602;">signalAll()</font>**`会唤醒所有等待线程；
+ 唤醒线程从`**<font style="color:#74B602;">await()</font>**`返回后需要重新获得锁。

此外，和`tryLock()`类似，`await()`可以在等待指定时间后，如果还没有被其他线程通过`signal()`或`signalAll()`唤醒，可以自己醒来。

```java
if (condition.await(1, TimeUnit.SECOND)) {
    // 被其他线程唤醒
} else {
    // 指定时间内没有被其他线程唤醒
}
```



## `ReadWriteLock`
前面讲到的`ReentrantLock`保证了只有一个线程可以执行临界区代码。

```java
public class Counter {
    private final Lock lock = new ReentrantLock();
    private int[] counts = new int[10];

    public void inc(int index) {
        lock.lock();
        try {
            counts[index] += 1;
        } finally {
            lock.unlock();
        }
    }

    public int[] get() {
        lock.lock();
        try {
            return Arrays.copyOf(counts, counts.length);
        } finally {
            lock.unlock();
        }
    }
}
```

但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用`inc()`方法是必须获取锁，但是，`get()`方法只读取数据，不修改数据，它实际上允许多个线程同时调用。

实际上我们想要的是：**允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待。**

| 多线程 | 读 | 写 |
| :---: | :---: | :---: |
| 读 | 允许 | 不允许 |
| 写 | 不允许 | 不允许 |


使用`ReadWriteLock`可以解决这个问题，它保证：

+ **只允许一个线程写入（其他线程既不能写入也不能读取）；**
+ **没有写入时，多个线程允许同时读（提高性能）。**

用`ReadWriteLock`实现这个功能十分容易。我们需要创建一个`ReadWriteLock`实例，然后分别获取读锁和写锁。

```java
public class Counter {
    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
    // 注意: 一对读锁和写锁必须从同一个rwlock获取。
    private final Lock rlock = rwlock.readLock();
    private final Lock wlock = rwlock.writeLock();
    private int[] counts = new int[10];

    public void inc(int index) {
        wlock.lock(); // 加写锁
        try {
            counts[index] += 1;
        } finally {
            wlock.unlock(); // 释放写锁
        }
    }

    public int[] get() {
        rlock.lock(); // 加读锁
        try {
            return Arrays.copyOf(counts, counts.length);
        } finally {
            rlock.unlock(); // 释放读锁
        }
    }
}
```

把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。

使用`ReadWriteLock`时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。

例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用`ReadWriteLock`。



## 8. `StampedLock`
前面介绍的`ReadWriteLock`可以解决多线程同时读，但只有一个线程能写的问题。

**在深入分析ReadWriteLock时，我们可以注意到一个潜在的问题。当有线程在读取时，写线程必须等待直到读线程释放锁之后才能获得写锁。这意味着在读取期间不允许写入，体现了一种悲观的读锁策略（即读者优先）。**

要进一步提升并发执行效率，Java 8引入了新的读写锁：`StampedLock`。

**与ReadWriteLock相比，StampedLock的改进之处在于它允许在读取过程中获取写锁进行写入。这可能导致读取的数据不一致，因此需要额外的代码来检测读取过程中是否发生了写入，这种读锁被称为乐观锁。**

乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。

```java
public class Point {
    private final StampedLock stampedLock = new StampedLock();
    private double x;
    private double y;

    // 移动点的位置
    public void move(double deltaX, double deltaY) {
        long stamp = stampedLock.writeLock(); // 获取写锁
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            stampedLock.unlockWrite(stamp); // 释放写锁
        }
    }

    // 计算点到原点的距离
    public double distanceFromOrigin() {
        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁
        // 注意：下面两行代码不是原子操作
        double currentX = x; // 假设 x, y = (100, 200)
        double currentY = y; // 此时可能存在写线程将 x, y 修改为 (300, 400)

        // 检查乐观读锁期间是否有写锁发生
        if (!stampedLock.validate(stamp)) {
            stamp = stampedLock.readLock(); // 获取一个悲观读锁
            try {
                currentX = x;
                currentY = y;
            } finally {
                stampedLock.unlockRead(stamp); // 释放悲观读锁
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
}
```

和`ReadWriteLock`相比，写入的加锁是完全一样的，不同的是读取。

> [!NOTE] 注意
> 注意到首先我们通过**`tryOptimisticRead()`**获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过**`validate()`**去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。

由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。

> [!tip] Tips
> 显然，`StampedLock`将读锁细分为**乐观读**和**悲观读**，这样可以进一步提高并发效率。然而，这样做也有其代价。首先，代码变得更复杂；其次，StampedLock是一种不可重入的锁，无法在同一线程中多次获取同一个锁。
> - 在高写入负载的场景下，悲观读锁可能会被长期阻塞，导致读操作饥饿。
> - 如果线程使用 `writeLock()` 或者 `readLock()` 获得锁之后，线程还没执行完就被 `interrupt()` 的话，会导致 CPU 飙升，需要用 `readLockInterruptibly` 或者 `writeLockInterruptibly` 。

StampedLock也支持将悲观读锁升级为写锁的更高级功能，这主要应用于`if-then-update`场景：先进行读取，如果读取的数据符合条件，则直接返回；如果不符合条件，则尝试进行写操作。

> [!info] 内部原理
> - `StampedLock` 通过一个长整型值来管理状态，低位用于表示锁的类型（写锁、读锁），高位用于表示锁的计数。当乐观读锁被获取时，生成一个时间戳（stamp），并在后续验证时判断是否有写操作发生。
> -  `validate(stamp)` 方法可以有效判断在持有乐观读锁的情况下，是否有其他写操作干扰（被修改了），从而决定是否要变为悲观读锁。

## 9. `Semaphore`信号量
前面我们讲了各种锁的实现，本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（`ReentrantLock`），或者只有一个线程能写入（`ReadWriteLock`）。

> [!WARNING]
> **存在一种资源限制，它确保同一时间最多只有N个线程可以访问。例如，同一时间最多只能创建100个数据库连接，或者最多允许10个用户同时下载等。**

这种限制数量的锁，如果用Lock数组来实现，就太麻烦了。

这种情况就可以使用`Semaphore`，例如，最多允许3个线程同时访问。

```java
public class AccessLimitControl {
    // 任意时刻仅允许最多3个线程获取许可:
    final Semaphore semaphore = new Semaphore(3);

    public String access() throws Exception {
        // 如果超过了许可数量,其他线程将在此等待
        semaphore.acquire();
        try {
            // TODO
            return UUID.randomUUID().toString();
        } finally {
            semaphore.release();
        }
    }
}
```

使用`Semaphore`先调用`acquire()`获取，然后通过`try ... finally`保证在`finally`中释放。

调用`acquire()`可能会进入等待，直到满足条件为止。

也可以使用`tryAcquire()`指定等待时间：

```java
if (semaphore.tryAcquire(3, TimeUnit.SECONDS)) {
    // 指定等待时间3秒内获取到许可:
    try {
        // TODO:
    } finally {
        semaphore.release();
    }
}
```

`Semaphore`本质上就是一个**信号计数器**，用于限制同一时间的最大访问数量。



## `Concurrent集合`
我们在前面已经通过`ReentrantLock`和`Condition`实现了一个`BlockingQueue`：

```java
public class TaskQueue {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private Queue<String> queue = new LinkedList<>();

    public void addTask(String s) {
        lock.lock();
        try {
            queue.add(s);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public String getTask() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                condition.await();
            }
            return queue.remove();
        } finally {
            lock.unlock();
        }
    }
}
```

`BlockingQueue`的意思就是说，当一个线程调用这个`TaskQueue`的`getTask()`方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，`getTask()`方法才会返回。

因为`BlockingQueue`非常有用，所以我们不必自己编写，可以直接使用Java标准库的`java.util.concurrent`包提供的线程安全的集合：`ArrayBlockingQueue`。

除了`BlockingQueue`外，针对`List`、`Map`、`Set`、`Deque`等，`java.util.concurrent`包也提供了对应的并发集合类。

| Collection Type | Non-Thread-Safe Implementation | Thread-Safe Implementation |
| :---: | :---: | :---: |
| `List` | `ArrayList` | `CopyOnWriteArrayList` |
| `Map` | `HashMap` | `ConcurrentHashMap` |
| `Set` | `HashSet / TreeSet` | `CopyOnWriteArraySet` |
| `Queue` | `ArrayDeque / LinkedList` | `ArrayBlockingQueue / LinkedBlockingQueue` |
| `Deque` | `ArrayDeque / LinkedList` | `LinkedBlockingDeque` |


使用这些并发集合与使用非线程安全的集合类完全相同。

我们以`ConcurrentHashMap`为例：

```java
Map<String, String> map = new ConcurrentHashMap<>();
// 在不同的线程读写:
map.put("A", "1");
map.put("B", "2");
map.get("A", "1");
```

因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。

```java
Map<String, String> map = new ConcurrentHashMap<>();
```

`java.util.Collections`工具类还提供了一个旧的线程安全集合转换器，可以这么用：

```java
Map unsafeMap = new HashMap();
Map threadSafeMap = Collections.synchronizedMap(unsafeMap);
```

但是它实际上是用一个包装类包装了非线程安全的`Map`，然后对所有读写方法都用`synchronized`加锁，这样获得的线程安全集合的性能比`java.util.concurrent`集合要低很多，所以不推荐使用。



## `Atomic`
Java的`java.util.concurrent`包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于`java.util.concurrent.atomic`包。

我们以`AtomicInteger`为例，它提供的主要操作有：

+ 增加值并返回新值：`int addAndGet(int delta)`
+ 加1后返回新值：`int incrementAndGet()`
+ 获取当前值：`int get()`
+ 用CAS方式设置：`int compareAndSet(int expect, int update)`

Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。

如果我们自己通过CAS编写`incrementAndGet()`，它大概长这样：

```java
public int incrementAndGet(AtomicInteger var) {
// 定义两个局部变量：
// prev 用于存储当前值，next 用于存储自增后的值
int prev, next;

// 使用 do-while 循环不断尝试更新值，直到成功为止
do {
    // 获取 AtomicInteger 当前的值并赋给 prev
    prev = var.get();
    // 计算自增后的值 next
    next = prev + 1;
    // 使用 compareAndSet 进行 CAS（Compare-And-Swap）操作
    // compareAndSet 会将 AtomicInteger 的值与 prev 比较：
    // - 如果相等，说明在这次获取和设置之间没有其他线程修改过值，
    //   因此可以安全地将值从 prev 更新为 next，并返回 true 表示成功
    // - 如果不相等，说明在此期间另一个线程修改了该值，
    //   则 compareAndSet 返回 false，此时进入下一次循环重新获取最新值
} while (!var.compareAndSet(prev, next));

// 返回最终成功更新的值 next
return next;
}
```

我们利用`AtomicLong`可以编写一个**多线程安全的全局唯一ID生成器**：

```java
import java.util.concurrent.atomic.AtomicLong;

public class IdGenerator {
    // 使用 AtomicLong 类型来保存当前的 ID 值，并将其初始化为 0
    // AtomicLong 是一个线程安全的长整型变量，它的原子操作方法可以确保在多线程环境下正确递增
    private final AtomicLong var = new AtomicLong(0);

    // 获取下一个唯一 ID 的方法
    public long getNextId() {
        // 使用 AtomicLong 的 incrementAndGet() 方法
        // 该方法会以原子方式将当前值自增 1，并返回自增后的值
        // AtomicLong 的 incrementAndGet() 操作是线程安全的，
        // 因此即使在多线程环境下调用该方法，也能确保每次获取到的 ID 是唯一且递增的
        return var.incrementAndGet();
    }

    public static void main(String[] args) {
        // 创建 IdGenerator 实例
        IdGenerator idGenerator = new IdGenerator();

        // 启动多个线程，测试 ID 生成器是否线程安全
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int j = 0; j < 5; j++) {
                    System.out.println("Generated ID: " + idGenerator.getNextId());
                }
            }).start();
        }
    }
}
```

通常情况下，我们并不需要直接用`do ... while`循环调用`compareAndSet`实现复杂的并发操作，而是用`incrementAndGet()`这样的封装好的方法，因此，使用起来非常简单。

在高度竞争的情况下，还可以使用Java 8提供的`LongAdder`和`LongAccumulator`。

