---

## `ThreadLocal`
多线程是Java实现多任务的基础，`Thread`对象代表一个线程，我们可以在代码中调用`Thread.currentThread()`获取当前线程。

例如，打印日志时，可以同时打印出当前线程的名字：

```java
// Thread
public class Main {
    public static void main(String[] args) throws Exception {
        log("start main...");
        new Thread(() -> {
            log("run task...");
        }).start();
        new Thread(() -> {
            log("print...");
        }).start();
        log("end main.");
    }
    static void log(String s) {
        System.out.println(Thread.currentThread().getName() + ": " + s);
    }
}
```

对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。

Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：

```java
public void process(User user) {
checkPermission();
doWork();
saveStatus();
sendResponse();
}
```

然后，通过线程池去执行这些任务。

观察`process()`方法，它内部需要调用若干其他方法，同时，我们遇到一个问题：如何在一个线程内传递状态？

`process()`方法需要传递的状态就是`User`实例。

有的童鞋会想，简单地传入`User`就可以了。

```java
public void process(User user) {
checkPermission(user);
doWork(user);
saveStatus(user);
sendResponse(user);
}
```

但是往往一个方法又会调用其他很多方法，这样会导致`User`传递到所有地方：

```java
void doWork(User user) {
queryStatus(user);
checkStatus();
setNewStatus(user);
log();
}
```

**<font style="background-color:rgb(254,234,210);">这种在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。</font>**

给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，`User`对象就传不进去了。

Java标准库提供了一个特殊的`ThreadLocal`，它可以在一个线程中传递同一个对象。

`**<font style="background-color:rgb(254,234,210);">ThreadLocal</font>**`**<font style="background-color:rgb(254,234,210);"> 是 JDK 包提供的，它提供了线程本地变量 ，也就是如果你创建了 一 个</font>**`**<font style="background-color:rgb(254,234,210);">ThreadLocal </font>**`**<font style="background-color:rgb(254,234,210);">变量 ，那么访问这个变量的每个线程都会有这个变量的一个本地副本 。 当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。 </font>**

![](https://cdn.nlark.com/yuque/0/2024/png/43007687/1731851418188-f64fb41c-96bf-4cad-8a46-891fc1df3246.png)

## `Threadlocal `的实现原理 
首先看一下 ThreadLocal 相关类的类图结构 :

![](https://cdn.nlark.com/yuque/0/2024/png/43007687/1731851418227-cd3ffeef-5021-49ac-a438-b33e8b832afe.png)

`<font style="background-color:rgb(253,226,226);">Thread</font>`<font style="background-color:rgb(253,226,226);"> 类中有一个 </font>`<font style="background-color:rgb(253,226,226);">threadLocals</font>`<font style="background-color:rgb(253,226,226);"> 和一个 </font>`<font style="background-color:rgb(253,226,226);">inheritableThreadLocals</font>`<font style="background-color:rgb(253,226,226);"> ，它们都是 </font>`<font style="background-color:rgb(253,226,226);">ThreadLocalMap</font>`<font style="background-color:rgb(253,226,226);"> 类型的变量 ，</font><u><font style="background-color:rgb(253,226,226);">而</font></u>`<u><font style="background-color:rgb(253,226,226);">ThreadLocalMap</font></u>`<u><font style="background-color:rgb(253,226,226);"> 是一个定制化的 </font></u>`<u><font style="background-color:rgb(253,226,226);">Hashmap</font></u>`<u><font style="background-color:rgb(253,226,226);"> </font></u><font style="background-color:rgb(253,226,226);">。 在默认情况下，每个线程中的这两个变量都为 </font>`<font style="background-color:rgb(253,226,226);">null</font>`<font style="background-color:rgb(253,226,226);">，只有当前线程第一次调用 </font>`<font style="background-color:rgb(253,226,226);">ThreadLocal</font>`<font style="background-color:rgb(253,226,226);"> 的 </font>`<font style="background-color:rgb(253,226,226);">set</font>`<font style="background-color:rgb(253,226,226);"> 或者 </font>`<font style="background-color:rgb(253,226,226);">get</font>`<font style="background-color:rgb(253,226,226);"> 方法时才会创建它们 。 </font>

<font style="background-color:rgb(253,226,226);">其实每个线程的本地变量不是存放在 </font>`<font style="background-color:rgb(253,226,226);">ThreadLocal</font>`<font style="background-color:rgb(253,226,226);"> 实例里面，而是存放在调用线程的 </font>`<font style="background-color:rgb(253,226,226);">threadLocals</font>`<font style="background-color:rgb(253,226,226);"> 变量里面 。也就是说 ，</font>`<font style="background-color:rgb(253,226,226);">ThreadLocal</font>`<font style="background-color:rgb(253,226,226);">类型的本地变量存放在具体的线程内存空间中 。 </font>`<font style="background-color:rgb(253,226,226);">ThreadLocal</font>`<font style="background-color:rgb(253,226,226);"> 就是一个工具壳，它通过 </font>`<font style="background-color:rgb(253,226,226);">set</font>`<font style="background-color:rgb(253,226,226);">方法把 </font>`<font style="background-color:rgb(253,226,226);">value</font>`<font style="background-color:rgb(253,226,226);"> 值放入调用线程的 </font>`<font style="background-color:rgb(253,226,226);">threadLocals</font>`<font style="background-color:rgb(253,226,226);"> 里面并存放起来 ，当调用线程调用它的</font>`<font style="background-color:rgb(253,226,226);">get</font>`<font style="background-color:rgb(253,226,226);">方法时，再从当前线程的</font>`<font style="background-color:rgb(253,226,226);">threadLocals</font>`<font style="background-color:rgb(253,226,226);">变量里面将其拿出来使用。如果调用线程一直不终止，那么这个本地变量会一直存放在调用线程的 </font>`<font style="background-color:rgb(253,226,226);">threadLocals</font>`<font style="background-color:rgb(253,226,226);"> 变量里面 ，所以当不需要使用本地变量时可以通过调用 </font>`<font style="background-color:rgb(253,226,226);">ThreadLocal</font>`<font style="background-color:rgb(253,226,226);"> 变量的 </font>`<font style="background-color:rgb(253,226,226);">remove</font>`<font style="background-color:rgb(253,226,226);"> 方法，从当前线程的 </font>`<font style="background-color:rgb(253,226,226);">threadLocals</font>`<font style="background-color:rgb(253,226,226);"> 里面删除该本地变量 。另外，</font>`<font style="background-color:rgb(253,226,226);">Thread</font>`<font style="background-color:rgb(253,226,226);"> 里面 的 </font>`<font style="background-color:rgb(253,226,226);">threadLocals</font>`<font style="background-color:rgb(253,226,226);"> 为何被设计为 </font>`<font style="background-color:rgb(253,226,226);">map</font>`<font style="background-color:rgb(253,226,226);"> 结构？很明显是因为每个线程可以关联多个 </font>`<font style="background-color:rgb(253,226,226);">ThreadLocal</font>`<font style="background-color:rgb(253,226,226);"> 变量。 </font>

## `Threadlocal`的使用
`ThreadLocal`实例通常总是以静态字段初始化如下：

```java
static ThreadLocal<User> threadLocalUser = new ThreadLocal<>();
```

它的典型使用方式如下：

```java
void processUser(user) {
    try {
        threadLocalUser.set(user);
        step1();
        step2();
        log();
    } finally {
        threadLocalUser.remove();
    }
}
```

通过设置一个`User`实例关联到`ThreadLocal`中，在移除之前，所有方法都可以随时获取到该`User`实例：

```java
void step1() {
    User u = threadLocalUser.get();
    log();
    printUser();
}

void step2() {
    User u = threadLocalUser.get();
    checkUser(u.id);
}

void log() {
    User u = threadLocalUser.get();
    println(u.name);
}
```

**<font style="background-color:rgb(254,234,210);">请注意，普通方法的调用总是由同一个线程执行，因此，在</font>**`**<font style="background-color:rgb(254,234,210);">step1()</font>**`**<font style="background-color:rgb(254,234,210);">、</font>**`**<font style="background-color:rgb(254,234,210);">step2()</font>**`**<font style="background-color:rgb(254,234,210);">和</font>**`**<font style="background-color:rgb(254,234,210);">log()</font>**`**<font style="background-color:rgb(254,234,210);">方法中，通过</font>**`**<font style="background-color:rgb(254,234,210);">threadLocalUser.get()</font>**`**<font style="background-color:rgb(254,234,210);">获取的User对象都是同一个实例。</font>**

实际上，可以把`ThreadLocal`看成一个全局`Map<Thread, Object>`：每个线程获取`ThreadLocal`变量时，总是使用`Thread`自身作为key：

```java
Object threadLocalValue = threadLocalMap.get(Thread.currentThread());
```

因此，`ThreadLocal`相当于给每个线程都开辟了一个独立的存储空间，各个线程的`ThreadLocal`关联的实例互不干扰。

**<font style="background-color:rgb(254,234,210);">最后，务必注意在finally块中清除ThreadLocal。</font>**

```java
try {
    threadLocalUser.set(user);
    ...
} finally {
    threadLocalUser.remove();
}
```

这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果`ThreadLocal`没有被清除，该线程执行其他代码时，会把上一次的状态带进去。

为了保证能释放`ThreadLocal`关联的实例，我们可以通过`AutoCloseable`接口配合`try (resource) {...}`结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的`ThreadLocal`可以封装为一个`UserContext`对象：

```java
public class UserContext implements AutoCloseable {

    static final ThreadLocal<String> ctx = new ThreadLocal<>();

    public UserContext(String user) {
        ctx.set(user);
    }

    public static String currentUser() {
        return ctx.get();
    }

    @Override
    public void close() {
        ctx.remove();
    }
}
```

使用的时候，我们借助`try (resource) {...}`结构，可以这么写：

```java
try (var ctx = new UserContext("Bob")) {
    // 可任意调用UserContext.currentUser()
    String currentUser = UserContext.currentUser();
} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象
```

这样就在`UserContext`中完全封装了`ThreadLocal`，外部代码在`try (resource) {...}`内部可以随时调用`UserContext.currentUser()`获取当前线程绑定的用户名。

## `lnheritableThreadLocal`类
当一个`ThreadLocal`变量在父线程中设定后，它在子线程中是无法获取的。这是因为当子线程中调用get方法时，当前线程是子线程，而set方法是在主线程中调用来设定线程变量的，因此两个线程是不同的，子线程在访问时会返回null。那么，是否有方法允许子线程访问到父线程中的值呢？确实有办法。

为了应对这一问题，`InheritableThreadLocal`被创造出来。`InheritableThreadLocal`是`ThreadLocal`的子类，它允许子线程访问在父线程中设置的本地变量。

```java
public class InheritableThreadLocal<T> extends ThreadLocal<T> {

    // 重写 createMap 方法，创建 inheritableThreadLocals 实例
    @Override
    void createMap(Thread t, T firstValue) {
        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);
    }

    // 重写 getMap 方法，优先获取 inheritableThreadLocals
    @Override
    ThreadLocalMap getMap(Thread t) {
        return t.inheritableThreadLocals;
    }

    // 添加子线程变量值的继承逻辑
    protected T childValue(T parentValue) {
        return parentValue;
    }
}
```

`InheritableThreadLocal` 继承了 `ThreadLocal`，并重写了三个方法：`createMap`、`childValue` 和 `getMap`。

+ 根据 `createMap` 方法的实现可以看出，当第一次调用 `set` 方法时，`InheritableThreadLocal` 会创建当前线程的 `inheritableThreadLocals` 实例，而不是 `threadLocals` 实例。这是通过重写 `createMap` 方法实现的，从而确保子线程能够继承父线程的变量。
+ 根据 `getMap` 方法的实现，当调用 `get` 方法获取当前线程内部的变量时，`InheritableThreadLocal` 会优先访问 `inheritableThreadLocals` 而非 `threadLocals`，使得继承关系得以维持。

通过上述机制，`InheritableThreadLocal` 实现了线程间变量的继承功能。

```java
public class InheritableThreadLocalExample {
    // 创建 InheritableThreadLocal 实例
    private static final InheritableThreadLocal<String> threadLocal = new InheritableThreadLocal<>();

    public static void main(String[] args) {
        // 设置父线程的变量
        threadLocal.set("Parent Thread Value");
        System.out.println("Main Thread Value: " + threadLocal.get());
        // 创建子线程
        Thread childThread = new Thread(() -> {
            System.out.println("Child Thread Value (Inherited): " + threadLocal.get());
            // 子线程修改自己的变量值
            threadLocal.set("Child Thread Modified Value");
            System.out.println("Child Thread Value (Modified): " + threadLocal.get());
        });
        childThread.start();
        // 等待子线程执行完成
        try {
            childThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        // 父线程的变量值不受子线程影响
        System.out.println("Main Thread Value After Child Modification: " + threadLocal.get());
    }
}
```

```plain
运行结果: 
Main Thread Value: Parent Thread Value
Child Thread Value (Inherited): Parent Thread Value
Child Thread Value (Modified): Child Thread Modified Value
Main Thread Value After Child Modification: Parent Thread Value
```

从案例代码的运行结果中，我们可以得知。

1. **子线程修改值**：子线程修改自己的 `InheritableThreadLocal` 值不会影响父线程中的值。
2. **线程隔离性**：每个线程对 `InheritableThreadLocal` 的值修改仅影响自身的拷贝，实现线程隔离的同时提供继承能力。

<font style="background-color:rgb(253,226,226);">总结：</font>`<font style="background-color:rgb(253,226,226);">InheritableThreadLocal</font>`<font style="background-color:rgb(253,226,226);"> 类通过重写 </font>`<font style="background-color:rgb(253,226,226);">createMap</font>`<font style="background-color:rgb(253,226,226);"> 和 </font>`<font style="background-color:rgb(253,226,226);">getMap</font>`<font style="background-color:rgb(253,226,226);"> 方法，将本地变量保存到具体线程的 </font>`<font style="background-color:rgb(253,226,226);">inheritableThreadLocals</font>`<font style="background-color:rgb(253,226,226);"> 变量中，使得在通过 </font>`<font style="background-color:rgb(253,226,226);">InheritableThreadLocal</font>`<font style="background-color:rgb(253,226,226);"> 实例的 </font>`<font style="background-color:rgb(253,226,226);">set</font>`<font style="background-color:rgb(253,226,226);"> 或 </font>`<font style="background-color:rgb(253,226,226);">get</font>`<font style="background-color:rgb(253,226,226);"> 方法设置或获取变量时，会优先操作当前线程的 </font>`<font style="background-color:rgb(253,226,226);">inheritableThreadLocals</font>`<font style="background-color:rgb(253,226,226);"> 变量；当父线程创建子线程时，子线程的构造函数会将父线程中 </font>`<font style="background-color:rgb(253,226,226);">inheritableThreadLocals</font>`<font style="background-color:rgb(253,226,226);"> 变量里的本地变量复制一份，并保存到子线程的 </font>`<font style="background-color:rgb(253,226,226);">inheritableThreadLocals</font>`<font style="background-color:rgb(253,226,226);"> 变量中，从而实现变量的继承机制。</font>

