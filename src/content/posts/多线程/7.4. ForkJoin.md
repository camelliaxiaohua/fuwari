---
title: ForkJoin
category: 并发
tags:
  - 多线程
---
---

`ForkJoin`是 Java 7 引入的一个并行计算框架，主要用于**将一个大任务拆分成多个小任务并行执行**，最后将结果合并。它是基于 **分治法（Divide and Conquer）的思想设计的，特别适合处理可以递归分解的任务。

`ForkJoin`框架的核心类是 `ForkJoinPool` 和 `ForkJoinTask`<font style="color:rgb(64, 64, 64);">。</font>`ForkJoinPool`是一个线程池，专门用于执行 `ForkJoinTask` 任务。`ForkJoinTask` 是一个抽象类，它的两个主要子类是 `RecursiveAction`（无返回值任务）和 `RecursiveTask`（有返回值任务）。

**例如：** 如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成。

```plain
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐   
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘   
```

还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行。

```plain
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐   
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘   
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐   
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘   
```

如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行。

```plain
┌─┬─┬─┬─┬─┬─┐    
└─┴─┴─┴─┴─┴─┘    
┌─┬─┬─┬─┬─┬─┐    
└─┴─┴─┴─┴─┴─┘    
┌─┬─┬─┬─┬─┬─┐    
└─┴─┴─┴─┴─┴─┘    
┌─┬─┬─┬─┬─┬─┐    
└─┴─┴─┴─┴─┴─┘    
```

**Fork/Join任务的原理：** 判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。

## 1. 核心组件

1. **`ForkJoinPool`**

> 是一个线程池，用于执行 `ForkJoinTask`任务。
>
> 使用工作窃取（Work-Stealing）算法，空闲线程可以从其他线程的任务队列中窃取任务执行，从而提高 CPU 利用率。


2. **`ForkJoinTask`**

> 是一个抽象类，表示可以被 `ForkJoinPool`执行的任务。
>
> 主要子类：
>
> + `RecursiveAction`：用于**没有返回值**的任务。
> 
> + `RecursiveTask`：用于**有返回值**的任务。
>

[RecursiveAction&RecursiveTask](https://github.com/camelliaxiaohua/juc/tree/ThreadPool/src/main/java/forkjoin)

3. **工作窃取算法（Work-Stealing）**

> 每个线程维护一个双端队列（Deque），存放自己的任务。
>
> 当一个线程的任务队列为空时，它会从其他线程的任务队列的尾部窃取任务执行。
>
> 这种机制可以减少线程的等待时间，提高并行效率。
>

## 2. 使用 ForkJoin的步骤

1. **定义任务**

> + 继承 `RecursiveAction` 或 `RecursiveTask`，并实现`compute()` 方法。
> + 在 `compute()` 方法中，判断任务是否需要拆分，如果需要则拆分成子任务并执行。
>

2. **提交任务**

> 将任务提交到 `ForkJoinPool` 中执行。
>

3. **获取结果</font>**

> 对于 `RecursiveTask`，可以通过`join()` 方法获取任务的结果。
>

我们来看如何使用Fork/Join对大数据进行并行求和：

```java
public class ForkJoinTaskExample {
    public static void main(String[] args) {
        // 创建一个大数组
        long[] array = new long[10000000];
        Random random = new Random();
        for (int i = 0; i < array.length; i++) {
            array[i] = random.nextInt(100);
        }
        // 记录开始时间
        long startTime = System.nanoTime();
        // 创建任务
        SumTask task = new SumTask(array, 0, array.length);
        // 创建 ForkJoinPool 并提交任务
        ForkJoinPool pool = new ForkJoinPool();
        long result = pool.invoke(task);
        // 记录结束时间
        long endTime = System.nanoTime();
        // 输出结果和耗时
        System.out.println("结果: " + result);
        System.out.println("执行时间: " + (endTime - startTime) / 1_000_000 + " 毫秒");
    }
}

class SumTask extends RecursiveTask<Long> {
    private final long[] array;
    private final int start;
    private final int end;
    private static final int THRESHOLD = 10; // 任务拆分的阈值

    public SumTask(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            // 直接执行任务
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        } else {
            // 拆分任务
            int mid = (start + end) / 2;
            SumTask leftTask = new SumTask(array, start, mid);
            SumTask rightTask = new SumTask(array, mid, end);
            //并行运行两个子任务
            invokeAll(leftTask, rightTask);
            long sum = leftTask.join() + rightTask.join();
            return sum;
        }
    }
}
```

观察上述代码的执行过程，一个大的计算任务首先分裂为两个小任务，这两个小任务仍然太大，继续分裂为更小的子任务。最后，计算结果被依次合并，得到最终结果。

因此，核心代码`SumTask`继承自`RecursiveTask`，在`compute()`方法中，关键是如何“分裂”出子任务并且提交子任务。

```java
@Override
protected Long compute() {
    if (end - start <= THRESHOLD) {
        // 直接执行任务
        long sum = 0;
        for (int i = start; i < end; i++) {
            sum += array[i];
        }
        return sum;
    } else {
        // 拆分任务
        int mid = (start + end) / 2;
        SumTask leftTask = new SumTask(array, start, mid);
        SumTask rightTask = new SumTask(array, mid, end);
        //并行运行两个子任务
        invokeAll(leftTask, rightTask);
        long sum = leftTask.join() + rightTask.join();
        return sum;
    }
}
```

Fork/Join线程池在Java标准库中就有应用，Java标准库提供的`java.util.Arrays.parallelSort(array)`可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。

