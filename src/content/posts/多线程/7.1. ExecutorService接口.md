---
title: 1. 多线程基础3
category: 并发
tags:
  - 多线程
published: 2022-08-10
updated: 2022-08-10
draft: true
---

Java标准库提供了`ExecutorService`接口表示线程池，它的典型用法如下：

```java
// 创建固定大小的线程池
ExecutorService executor = Executors.newFixedThreadPool(3);
// 提交任务
executor.submit(task1);
executor.submit(task2);
executor.submit(task3);
executor.submit(task4);
executor.submit(task5);
```

因为`ExecutorService`只是接口，Java标准库提供的几个常用实现类有：

:::danger
+ `**<font style="color:rgb(143,149,158);background-color:rgb(251,191,188);">FixedThreadPool</font>**`：线程数固定的线程池；
+ `**<font style="color:rgb(143,149,158);background-color:rgb(251,191,188);">CachedThreadPool</font>**`：线程数根据任务动态调整的线程池；
+ `**<font style="color:rgb(143,149,158);background-color:rgb(251,191,188);">SingleThreadExecutor</font>**`：仅单线程执行的线程池。

:::

创建这些线程池的方法都被封装到`Executors`这个类中。

## `FixedThreadPool`(<font style="background-color:#FBF5CB;">固定</font>的线程池)
```java
// thread-pool
import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        // 创建一个固定大小的线程池
        ExecutorService es = Executors.newFixedThreadPool(4);
        for (int i = 0; i < 6; i++) {
            es.submit(new Task("" + i));
        }
        // 关闭线程池:
        es.shutdown();
    }
}

class Task implements Runnable {
    private final String name;

    public Task(String name) {
        this.name = name;
    }

    @Overridepublic void run() {
        System.out.println("start task " + name);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }
        System.out.println("end task " + name);
    }
}
```

观察执行结果，我们一次性提交6个任务。由于线程池仅有4个线程，最初的4个任务将会并行执行。只有当线程变为空闲状态时，后续的两个任务才会执行。

:::danger
**程序结束时，应关闭线程池。**`**shutdown()**`**方法能够在所有当前任务执行完毕后关闭线程池。而**`**shutdownNow()**`**方法将立刻停止正在执行的任务，**`**awaitTermination()**`**方法会在指定时间内等待以便完成线程池的关闭。**

:::

## `CachedThreadPool`(<font style="background-color:#FBF5CB;">动态</font>调整的线程池）
如果我们把线程池改为`**CachedThreadPool**`，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。

```java
import java.util.concurrent.*;

public class CachedThreadPool {
    public static void main(String[] args) {
        ExecutorService es = Executors.newCachedThreadPool();
        for (int i = 0; i < 6; i++) {
            es.submit(new CachedThreadTask(""+i));
        }
        es.shutdown();
    }
}

class CachedThreadTask implements Runnable {  
    private String name;  

    public CachedThreadTask(String name) {  
        this.name = name;  
    }

    @Override   
    public void run() {    
        System.out.println(name+" is running");    
        try {    
            Thread.sleep(300);    
        } catch (InterruptedException e) {     
            e.printStackTrace();    
        }
        System.out.println(name+" is stopped");    
    }
}
```

## 🌕 `<font style="color:#DF2A3F;">ThreadPoolExecutor</font>`
`<font style="color:rgb(64, 64, 64);">ThreadPoolExecutor</font>`<font style="color:rgb(64, 64, 64);"> 是 Java 中用于管理线程池的核心类，它提供了更细粒度的控制来管理线程池的行为。相比于 </font>`<font style="color:rgb(64, 64, 64);">Executors</font>`<font style="color:rgb(64, 64, 64);"> 工厂类提供的简单线程池（如 </font>`<font style="color:rgb(64, 64, 64);">newFixedThreadPool</font>`<font style="color:rgb(64, 64, 64);">、</font>`<font style="color:rgb(64, 64, 64);">newCachedThreadPool</font>`<font style="color:rgb(64, 64, 64);"> 等），</font>`<font style="color:rgb(64, 64, 64);">ThreadPoolExecutor</font>`<font style="color:rgb(64, 64, 64);"> 允许你自定义线程池的核心参数，例如核心线程数、最大线程数、线程空闲时间、任务队列等。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/43007687/1738742241906-7203c4fa-0df1-48b5-be2d-85fb0a36e9d3.png)

### `ThreadPoolExecutor`核心参数
```java
public ThreadPoolExecutor( 
    int corePoolSize,          // 核心线程数
    int maximumPoolSize,       // 最大线程数
    long keepAliveTime,        // 线程空闲时间
    TimeUnit unit,             // 空闲时间单位
    BlockingQueue<Runnable> workQueue, // 任务队列
    ThreadFactory threadFactory,       // 线程工厂
    RejectedExecutionHandler handler   // 拒绝策略
)
```

+ `**<font style="color:rgb(64, 64, 64);">corePoolSize</font>**`<font style="color:rgb(64, 64, 64);">：核心线程数，即线程池中始终保持存活的线程数量，即使它们处于空闲状态。</font>
+ `**<font style="color:rgb(64, 64, 64);">maximumPoolSize</font>**`<font style="color:rgb(64, 64, 64);">：线程池中允许的最大线程数。当任务队列满了且当前线程数小于最大线程数时，线程池会创建新线程。</font>
+ `**<font style="color:rgb(64, 64, 64);">keepAliveTime</font>**`<font style="color:rgb(64, 64, 64);">：当线程数超过核心线程数时，多余的空闲线程在终止前等待新任务的最长时间。</font>
+ `**<font style="color:rgb(64, 64, 64);">unit</font>**`<font style="color:rgb(64, 64, 64);">：</font>`<font style="color:rgb(64, 64, 64);">keepAliveTime</font>`<font style="color:rgb(64, 64, 64);"> 的时间单位，例如 </font>`<font style="color:rgb(64, 64, 64);">TimeUnit.SECONDS</font>`<font style="color:rgb(64, 64, 64);">、</font>`<font style="color:rgb(64, 64, 64);">TimeUnit.MILLISECONDS</font>`<font style="color:rgb(64, 64, 64);"> 等。</font>
+ `**<font style="color:rgb(64, 64, 64);">workQueue</font>**`<font style="color:rgb(64, 64, 64);">：用于保存等待执行的任务的阻塞队列。</font>

> <font style="color:rgb(64, 64, 64);">常用的队列有：</font>
>
> `**<font style="color:rgb(64, 64, 64);">LinkedBlockingQueue</font>**`<font style="color:rgb(64, 64, 64);">：无界队列（除非指定容量）。</font>
>
> `**<font style="color:rgb(64, 64, 64);">ArrayBlockingQueue</font>**`<font style="color:rgb(64, 64, 64);">：有界队列。</font>
>
> `**<font style="color:rgb(64, 64, 64);">SynchronousQueue</font>**`<font style="color:rgb(64, 64, 64);">：不存储任务的队列，每个插入操作必须等待一个移除操作。</font>
>

+ `**<font style="color:rgb(64, 64, 64);">threadFactory</font>**`<font style="color:rgb(64, 64, 64);">：用于创建新线程的工厂，可以自定义线程的名称、优先级等。</font>

> `**<font style="color:rgb(64, 64, 64);">Executors.defaultThreadFactory()</font>**`：`<font style="color:rgb(64, 64, 64);">Executors</font>`<font style="color:rgb(64, 64, 64);"> 工具类提供的默认线程工厂。它会创建普通的非守护线程，线程名称为 </font>`<font style="color:rgb(64, 64, 64);">pool-N-thread-M</font>`<font style="color:rgb(64, 64, 64);"> 的格式（</font>`<font style="color:rgb(64, 64, 64);">N</font>`<font style="color:rgb(64, 64, 64);"> 是线程池编号，</font>`<font style="color:rgb(64, 64, 64);">M</font>`<font style="color:rgb(64, 64, 64);"> 是线程编号）。</font>
>
> `**<font style="color:rgb(64, 64, 64);">Executors.privilegedThreadFactory()</font>**`**<font style="color:rgb(64, 64, 64);">：</font>**<font style="color:rgb(64, 64, 64);">这是一个特权线程工厂，创建的线程会继承当前线程的访问控制上下文（</font>`<font style="color:rgb(64, 64, 64);">AccessControlContext</font>`<font style="color:rgb(64, 64, 64);">）和类加载器。适用于需要特殊权限的场景。</font>
>
> **<font style="color:rgb(64, 64, 64);">自定义 </font>**`**<font style="color:rgb(64, 64, 64);">ThreadFactory</font>**`**<font style="color:rgb(64, 64, 64);"> 实现：</font>**<font style="color:rgb(64, 64, 64);">通过实现 </font>`<font style="color:rgb(64, 64, 64);">ThreadFactory</font>`<font style="color:rgb(64, 64, 64);"> 接口来完全控制线程的创建过程。例如，设置线程名称、优先级、是否为守护线程等。</font>
>

+ `**<font style="color:rgb(64, 64, 64);">handler</font>**`**<font style="color:rgb(64, 64, 64);">：</font>**<font style="color:rgb(64, 64, 64);">当任务队列已满且线程数达到最大线程数时，用于处理新任务的拒绝策略。</font>

> <font style="color:rgb(64, 64, 64);">常见的拒绝策略有：</font>
>
> `<font style="color:rgb(64, 64, 64);">ThreadPoolExecutor.AbortPolicy</font>`<font style="color:rgb(64, 64, 64);">：默认策略，直接抛出 </font>`<font style="color:rgb(64, 64, 64);">RejectedExecutionException</font>`<font style="color:rgb(64, 64, 64);">。</font>
>
> `<font style="color:rgb(64, 64, 64);">ThreadPoolExecutor.CallerRunsPolicy</font>`<font style="color:rgb(64, 64, 64);">：由提交任务的线程直接执行任务。</font>
>
> `<font style="color:rgb(64, 64, 64);">ThreadPoolExecutor.DiscardPolicy</font>`<font style="color:rgb(64, 64, 64);">：直接丢弃任务，不抛出异常。</font>
>
> `<font style="color:rgb(64, 64, 64);">ThreadPoolExecutor.DiscardOldestPolicy</font>`<font style="color:rgb(64, 64, 64);">：丢弃队列中最旧的任务，然后重新尝试提交当前任务。</font>
>

```java
import java.util.concurrent.*;

public class ThreadPoolExecutorExample {
    public static void main(String[] args) {
        // 创建线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, // 核心线程数
            4, // 最大线程数
            60, // 线程空闲时间
            TimeUnit.SECONDS, // 时间单位
            new LinkedBlockingQueue<>(10), // 任务队列
            Executors.defaultThreadFactory(), // 线程工厂
            new ThreadPoolExecutor.AbortPolicy() // 拒绝策略
        );
        // 提交任务
        for (int i = 0; i < 15; i++) {
            final int taskId = i;
            executor.execute(() -> {
                System.out.println("Task " + taskId + " is running on thread " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000); // 模拟任务执行
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        // 关闭线程池
        executor.shutdown();
    }
}
```

> <font style="color:rgb(64, 64, 64);">根据《阿里巴巴Java开发手册》，建议不要直接使用Executors来创建线程池，而是通过ThreadPoolExecutor的方式手动创建。因为Executors返回的线程池可能有资源耗尽的风险，比如FixedThreadPool和CachedThreadPool允许的请求队列长度和线程数量可能会导致OOM。</font>
>

## `ScheduledThreadPool`
`<font style="color:rgb(64, 64, 64);">ScheduledThreadPool</font>`<font style="color:rgb(64, 64, 64);"> 是 Java 中用于执行定时任务和周期性任务的线程池。它是通过 </font>`<font style="color:rgb(64, 64, 64);">ScheduledThreadPoolExecutor</font>`<font style="color:rgb(64, 64, 64);"> 类实现的，继承自 </font>`<font style="color:rgb(64, 64, 64);">ThreadPoolExecutor</font>`<font style="color:rgb(64, 64, 64);">，并实现了 </font>`<font style="color:rgb(64, 64, 64);">ScheduledExecutorService</font>`<font style="color:rgb(64, 64, 64);"> 接口。</font>`<font style="color:rgb(64, 64, 64);">ScheduledThreadPool</font>`<font style="color:rgb(64, 64, 64);"> 可以用于执行以下类型的任务：</font>

1. **<font style="color:rgb(64, 64, 64);">延迟任务</font>**<font style="color:rgb(64, 64, 64);">：在指定的延迟时间后执行任务。</font>
2. **<font style="color:rgb(64, 64, 64);">周期性任务</font>**<font style="color:rgb(64, 64, 64);">：以固定的间隔时间重复执行任务，或者以固定的延迟时间重复执行任务。</font>

创建一个`ScheduledThreadPool`仍然是通过`Executors`类。

```java
ScheduledExecutorService es = new ScheduledThreadPoolExecutor(5);
```

![](https://cdn.nlark.com/yuque/0/2025/png/43007687/1738749024232-f49b2b08-c5be-4aca-8319-df8f4d7e1d0b.png)

### `schedule`
我们可以提交一次性任务，它会在指定延迟后只执行一次：

```java
// 1秒后执行一次性任务
es.schedule(new Task("延迟任务"), 3, TimeUnit.SECONDS);
```

### `scheduleAtFixedRate`
如果任务以固定的每3秒执行，我们可以这样写：

```java
// 1秒后开始执行定时任务，每3秒执行。
es.scheduleAtFixedRate(new Task("固定频率任务"), 1, 3, TimeUnit.SECONDS);
```

### `scheduleWithFixedDelay`
如果任务以固定的3秒为间隔执行，我们可以这样写：

```java
// 1秒后开始执行定时任务，以3秒为间隔执行。
es.scheduleWithFixedDelay(new Task("固定延迟任务"), 1, 3, TimeUnit.SECONDS);
```

完整代码：

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ScheduledThreadPoolExample {
    public static void main(String[] args) {
        ScheduledExecutorService es = new ScheduledThreadPoolExecutor(5);
        try {
            es.schedule(new Task("延迟任务"), 3, TimeUnit.SECONDS);
            es.scheduleAtFixedRate(new Task("固定频率任务"), 1, 3, TimeUnit.SECONDS);
            es.scheduleWithFixedDelay(new Task("固定延迟任务"), 1, 3, TimeUnit.SECONDS);
            Thread.sleep(10000);
            es.shutdown();
        }catch (InterruptedException e){
            e.printStackTrace();
            es.shutdownNow();
        }finally {
            es.shutdownNow();
        }
    }
}

class Task implements Runnable {
    private String name;

    Task(String name){
        this.name = name;
    }
    public void run() {
        Thread.currentThread().setName(name);
        System.out.println(Thread.currentThread().getName() + " task is running");
    }
}
```

### `**FixedRate**`**和**`**FixedDelay**`**的区别。**
`FixedRate`是指任务总是以固定时间间隔触发，**不管任务执行多长时间**。

```plain
│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  
├───────┼───────┼───────┼───────┼────▶
│◀─────▶│◀─────▶│◀─────▶│◀─────▶│
```

而`FixedDelay`是指，**上一次任务执行完毕后**，等待固定的时间间隔，再执行下一次任务。

```plain
│░░░│       │░░░░░│       │░░│       │░
└───┼───────┼─────┼───────┼──┼───────┼──▶
    │◀─────▶│     │◀─────▶│  │◀─────▶│
```

因此，使用`ScheduledThreadPool`时，我们要根据需要选择执行一次、`FixedRate执行`还是`FixedDelay执行`。

细心的童鞋还可以思考下面的问题：

+ 在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？
    - **是否会并发执行**：是的，`ScheduledThreadPoolExecutor` 是支持并发执行的。假如任务的执行时间超过了设定的固定频率间隔（例如任务执行时间为 2 秒，但设定的是每秒触发一次），`ScheduledThreadPoolExecutor` 会尝试并行执行任务，确保触发频率不受影响。这会导致多个任务并发执行。
+ 如果任务抛出了异常，后续任务是否继续执行？
    - **异常处理**：如果任务抛出了异常且未捕获，`ScheduledThreadPoolExecutor` 会取消该任务的后续执行，导致该任务不再被调度。如果希望即使任务抛出异常后也能继续执行，可以在任务中捕获异常，避免抛出到 `ScheduledThreadPoolExecutor`。

Java标准库还提供了一个`java.util.Timer`类，这个类也可以定期执行任务，但是，一个`Timer`会对应一个`Thread`，所以，一个`Timer`只能定期执行一个任务，多个定时任务必须启动多个`Timer`，而一个`ScheduledThreadPool`就可以调度多个定时任务，所以，我们完全可以用`ScheduledThreadPool`取代旧的`Timer`。



