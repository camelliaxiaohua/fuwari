---
title: CompletableFuture
category: 并发
tags:
  - 多线程
  - 异步
published: 2024-05-07
updated: 2025-09-04
link: https://blog.csdn.net/zsx_xiaoxin/article/details/123898171?fromshare=blogdetail&sharetype=blogdetail&sharerId=123898171&sharerefer=PC&sharesource=qq_51665235&sharefrom=from_link
draft: true
---
---

使用 `Future` 获取异步执行结果时，有两种方式：要么调用阻塞方法 `get()`，等待任务完成再返回结果；要么通过轮询 `isDone()` 判断任务是否完成。这两种方式都有缺点，因为主线程都会被迫等待或者频繁检查，效率不高。

从 Java 8 开始，引入了 `CompletableFuture`，它对 `Future` 做了改进。使用 `CompletableFuture`，你可以给异步任务注册回调函数，当任务完成或者发生异常时，回调函数会自动被调用。这样主线程无需阻塞等待，也不用轮询，代码更加简洁、直观，并且可以方便地进行异步任务的链式组合和异常处理。

`CompletableFuture` 的功能可以概括为四大核心模块：**异步任务执行**、**回调处理**、**异常处理**和**组合操作**。通过这四大模块，你不仅可以轻松执行单个异步任务，还能高效地处理任务结果、管理异常，并方便地实现多个任务之间的依赖或并行操作，使复杂异步流程的编写变得直观而灵活。
## 1. 异步任务执行

**异步任务执行** 是 `CompletableFuture` 的基础。它允许你轻松地提交异步任务，而主线程无需等待任务完成。根据是否需要返回值，`CompletableFuture` 提供了两种方式：

1. **无返回值的异步任务**：使用 `runAsync(Runnable)` 提交任务，任务执行完成后不会返回结果。
    
2. **有返回值的异步任务**：使用 `supplyAsync(Supplier<U>)` 提交任务，任务执行完成后会返回结果。

### 1.1. `supplyAsync`

`supplyAsync`是创建带**有返回值**的异步任务。它有如下两个方法，一个是使用默认线程池`ForkJoinPool.commonPool()`的方法，一个是带有自定义线程池的重载方法。

+ **默认线程池**

```java
// 带返回值异步请求，默认线程池。
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
```

+ **自定义线程池**

```java
// 带返回值的异步请求，可以自定义线程池。
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)	
```

```java
public class SupplyAsyncExample {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();
        ExecutorService executor = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
        try{
            CompletableFuture <String> supplyAsync = CompletableFuture.supplyAsync(new CompletableTask(new Random().nextInt(10000000)), executor);
            CompletableFuture<Void> future = supplyAsync.thenAcceptAsync(new Consumer<String>() {
                @Override
                public void accept(String result) {
                    System.out.println(result);
                }
            });
            supplyAsync.exceptionallyAsync(new Function<Throwable, String>() {
                @Override
                public String apply(Throwable throwable) {
                    return "";
                }
            });
            future.join();
            long endTime = System.currentTimeMillis();
            System.out.println("耗时：" + (endTime - startTime) + "ms");
        }catch (Exception e){
            e.printStackTrace();
            executor.shutdownNow();
        }finally {
            executor.shutdown();
        }
    }
}


/**
 * 计算水仙花数的任务
 */
class CompletableTask implements Supplier<String> {

    private Integer number;
    // 构造函数，接受一个整数作为计算范围
    CompletableTask(Integer number){
        this.number = number;
    }

    @Override
    public String get() {
        // 设置当前线程的名字为当前计算范围
        Thread.currentThread().setName(number + "以内的水仙数为：");
        StringBuilder result = new StringBuilder();
        // 遍历所有数字，查找水仙花数
        for (int i = 1; i <= number; i++){
            if (isNarcissisticNumber(i)){
                result.append(i).append("\t"); // 将水仙花数添加到结果中
            }
        }
        // 返回计算结果，包含当前线程名称
        return Thread.currentThread().getName() + result;
    }

    /**
     * 判断一个数字是否为水仙花数
     */
    private boolean isNarcissisticNumber(int number){
        int originalNumber = number;
        int digits = String.valueOf(number).length(); // 计算数字的位数
        int sum = 0;
        // 计算每一位的数字的幂并求和
        while (number > 0){
            int digit = number % 10; // 获取数字的每一位
            sum += Math.pow(digit, digits); // 将该位数字的幂加到总和
            number /= 10; // 移除最后一位
        }
        // 如果总和等于原始数字，则为水仙花数
        return sum == originalNumber;
    }
}

```

### 1.2. `runAsync`

`runAsync`是创建没有返回值的异步任务。它有如下两个方法，一个是使用默认线程池`ForkJoinPool.commonPool()`的方法，一个是带有自定义线程池的重载方法。

+ **默认线程池**

```java
// 不带返回值的异步请求，默认线程池。
public static CompletableFuture<Void> runAsync(Runnable runnable)
```

+ **自定义线程池**

```java
// 不带返回值的异步请求，可以自定义线程池。
public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)
```

```java
public class RunAsyncExample { 
    public static void main(String[] args) {

        ExecutorService executor = new ThreadPoolExecutor(3, 6, 60L, java.util.concurrent.TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());

        try{
            CompletableFuture<Void> future = CompletableFuture.runAsync(new RunAsyncTask(), executor);

            future.join(); 
        }catch (Exception e){ 
            e.printStackTrace(); 
            executor.shutdownNow(); 
        }finally { 
            executor.shutdown(); 
        }
    }
}

class RunAsyncTask implements Runnable { 
    @Override 
    public void run(){ 
        System.out.println("start task");   
    }
}
```


## 2. 获取任务结果

在提交了异步任务之后，我们通常需要获取任务的执行结果，或者在某些场景下主动完成任务。`CompletableFuture` 提供了一系列方法来实现这些操作：

1. **获取异步任务结果**
    
    - `get()`：阻塞等待任务完成并返回结果。
        
    - `get(long timeout, TimeUnit)`：阻塞等待，但最多等待指定时间。
        
    - `join()`：类似 `get()`，但不抛 `InterruptedException`，异常会包装为 `CompletionException`。
        
    - `getNow(T valueIfAbsent)`：非阻塞获取结果，如果任务尚未完成，返回默认值。
        
    
    这些方法主要用于在异步任务执行完成后获取结果，无论是阻塞等待还是非阻塞立即获取，都能满足不同场景的需求。
    
2. **手动完成任务**
    
    - `complete(T value)`：如果任务尚未完成，可以手动设置结果并标记为完成。
        
    - `completeExceptionally(Throwable ex)`：如果任务尚未完成，可以手动标记任务异常完成。
        
    
    手动完成任务适用于需要主动控制任务状态的场景，比如提前终止任务或模拟任务完成。
    

通过这类方法，`CompletableFuture` 不仅支持自动异步执行，也允许开发者灵活地获取结果或主动完成任务，为后续的回调处理、异常处理和任务组合打下基础。

### 2.1. `get()`

```java
public T get() throws InterruptedException, ExecutionException
```

+ **作用**：阻塞当前线程，直到任务完成并返回结果。
+ **异常**：
    - `InterruptedException`：如果当前线程在等待过程中被中断。
    - `ExecutionException`：如果任务执行过程中抛出了异常。
+ **使用场景**：适用于需要等待任务完成并获取结果的场景。

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello");
String result = future.get(); // 阻塞等待结果
System.out.println(result); // 输出 "Hello"
```

### 2.2. `get(long timeout, TimeUnit unit)`

```java
public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
```

+ **作用**：阻塞当前线程，最多等待指定的时间，如果任务在指定时间内完成则返回结果，否则抛出 `TimeoutException`。
+ **异常**：
    - `InterruptedException`：如果当前线程在等待过程中被中断。
    - `ExecutionException`：如果任务执行过程中抛出了异常。
    - `TimeoutException`：如果任务在指定时间内未完成。
+ **使用场景**：适用于需要限制任务等待时间的场景。

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(2000); // 模拟耗时任务
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "Hello";
});

try {
    String result = future.get(1, TimeUnit.SECONDS); // 最多等待 1 秒
    System.out.println(result);
} catch (TimeoutException e) {
    System.out.println("任务超时未完成");
}
```

### 2.3.  `join()`

```java
public T join()
```

+ **作用**：阻塞当前线程，直到任务完成并返回结果。如果任务执行过程中抛出了异常，会抛出 `CompletionException`，并将原始异常作为原因。
+ **异常**：`CompletionException`（如果任务执行过程中抛出了异常）。
+ **使用场景**：适用于需要等待任务完成并获取结果的场景，且不需要显式处理 `InterruptedException`。

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello");
String result = future.join(); // 阻塞等待结果
System.out.println(result); // 输出 "Hello"
```

### 2.4. `getNow(T valueIfAbsent)`

```java
public T getNow(T valueIfAbsent)
```

+ **作用**：如果任务已经完成，则返回任务的结果；否则返回给定的默认值 `valueIfAbsent`。
+ **使用场景**：适用于不需要阻塞等待任务完成的场景，可以立即返回一个默认值。

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(2000); // 模拟耗时任务
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "Hello";
});

String result = future.getNow("Default Value"); // 如果任务未完成，返回 "Default Value"
System.out.println(result); // 输出 "Default Value"
```

### 2.5. `complete(T value)`

```java
public boolean complete(T value)
```

+ **作用**：如果**任务尚未完成**，则将其结果设置为给定值 `value`，并**标记任务为完成状态**。
+ **返回值**：如果任务尚未完成并且成功设置了结果，则返回 `true`；如果任务已经完成（无论是正常完成、异常完成，还是已取消），则返回 `false`。
+ **使用场景**：适用于手动控制任务完成的场景。

```java
CompletableFuture<String> future = new CompletableFuture<>();
future.complete("Manual Completion"); // 手动完成任务
System.out.println(future.join()); // 输出 "Manual Completion"
```

### 2.6. `completeExceptionally(Throwable ex)`

```java
public boolean completeExceptionally(Throwable ex)
```

+ **作用**：如果任务尚未完成，则将其状态标记为异常完成，并将给定异常 `ex` 作为任务的结果。
+ **返回值**：如果任务尚未完成并成功标记为异常完成，则返回 `true`；如果任务已经完成，则返回 `false`。
+ **使用场景**：适用于手动控制任务异常完成的场景。

```java
CompletableFuture<String> future = new CompletableFuture<>();
future.completeExceptionally(new RuntimeException("Task failed")); // 手动标记任务为异常完成

try {
    future.join();
} catch (CompletionException e) {
    System.out.println("任务异常: " + e.getCause().getMessage()); // 输出 "任务异常: Task failed"
}
```

## 3. 回调处理

在完成异步任务执行之后，往往需要对任务结果进行处理，这就用到了 `CompletableFuture` 的 **回调处理** 模块。与传统 `Future` 不同，`CompletableFuture` 支持注册回调函数，当异步任务完成后会自动触发回调，无需主线程阻塞等待，也不用轮询检查任务状态。

回调处理主要有三种形式：

1. **转换结果**：使用 `thenApply(Function)` 对任务结果进行加工或转换。
    
2. **消费结果**：使用 `thenAccept(Consumer)` 对结果进行消费，例如打印、写入数据库等，无需返回值。
    
3. **执行不依赖结果的操作**：使用 `thenRun(Runnable)` 在任务完成后执行某些操作，但不使用任务结果。
    
通过回调处理模块，可以将异步任务与后续操作自然衔接，实现链式调用，让代码逻辑更加清晰。

| 方法                  | 作用           | 线程执行     | 是否返回新值 |
| ------------------- | ------------ | -------- | :----: |
| `thenApply`         | 转换结果         | **当前线程** |   ✅    |
| `thenApplyAsync`    | 转换结果         | **线程池**  |   ✅    |
| `thenAccept`        | 消费结果         | **当前线程** |   ❌    |
| `thenAcceptAsync`   | 消费结果         | **线程池**  |   ❌    |
| `thenRun`           | 运行新任务（不关心结果） | **当前线程** |   ❌    |
| `thenRunAsync`      | 运行新任务（不关心结果） | **线程池**  |   ❌    |
| `whenComplete`      | 处理完成（不修改结果）  | **当前线程** |   ❌    |
| `whenCompleteAsync` | 处理完成（不修改结果）  | **线程池**  |   ❌    |
| `handle`            | 处理完成（可修改结果）  | **当前线程** |   ✅    |
| `handleAsync`       | 处理完成（可修改结果）  | **线程池**  |   ✅    |

### 3.1. `thenApply` 和 `thenApplyAsync`

`thenApply` 和 `thenApplyAsync` 用于在异步任务完成后**继续处理结果**，并**返回一个新的 **`**CompletableFuture**`。

#### 3.1.1. `thenApply`

`thenApply` 是同步操作，它会在当前 `CompletableFuture` 完成时立即对结果进行处理，并返回一个新的 `CompletableFuture`，因此可以链式调用多个操作。这个方法会在当前线程中执行后续的操作，也就是说，它是阻塞的，直到该操作执行完成。

```java
<U> CompletableFuture<U> thenApply(Function<? super T, ? extends U> fn);
```

+ `T`：当前 `CompletableFuture` 完成时的类型。
+ `U`：返回的新的 `CompletableFuture` 类型。
+ `fn`：用于处理当前结果的函数，它接受当前计算的结果 `T`，并返回一个新的结果 `U`。

```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
CompletableFuture<String> result = future.thenApply(value -> "Result: " + value);
result.thenAccept(System.out::println);  // 输出: Result: 5
```

#### 3.1.2. `thenApplyAsync`

`thenApplyAsync` 与 `thenApply` 类似，不同之处在于它是异步执行的。这个方法会将后续操作提交给默认的异步执行器，或者如果你指定了执行器的话，它会使用指定的执行器。

```java
<U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn);
<U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends U> fn, Executor executor);
```

+ `T`：当前 `CompletableFuture` 完成时的类型。
+ `U`：返回的新的 `CompletableFuture` 类型。
+ `fn`：用于处理当前结果的函数，它接受当前计算的结果 `T`，并返回一个新的结果 `U`。
+ `executor`（可选）：用于执行操作的线程池。如果未指定，默认使用 `ForkJoinPool.commonPool()`。

```java
Executor executor = Executors.newFixedThreadPool(2);
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
CompletableFuture<String> result = future.thenApplyAsync(value -> "Async Result: " + value, executor);
result.thenAccept(System.out::println);  // 异步执行，输出: Async Result: 5
```

### 3.2. `thenAccept` 和 `thenAcceptAsync`

`thenAccept` 和 `thenAcceptAsync` 用于在异步任务完成后执行某个动作，消费前一个 `CompletableFuture` 的结果，但**不会返回新值**。

#### 3.2.1. `thenAccept`

`thenAccept` 方法用于消费 `CompletableFuture` 计算的结果，但它不会返回任何结果。你可以在 `thenAccept` 中指定一个 `Consumer` 函数，这个函数会在 `CompletableFuture` 完成后执行。注意，它是同步执行的，即在当前线程中执行。

```java
void thenAccept(Consumer<? super T> action);
```

+ `action`：一个 `Consumer`，用于处理 `CompletableFuture` 完成时的结果。

> [!danger] 警告
> `thenAccept` 会在当前 `CompletableFuture` 完成时被调用，并且会在同一线程中执行。它不会返回一个新的 `CompletableFuture`，即它只是一个终端操作。

```java
import java.util.concurrent.CompletableFuture; 

public class ThenAcceptExample { 
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
        future.thenAccept(value -> System.out.println("The result is: " + value));  
        // 输出: The result is: 5
    }
}
```

#### 3.2.2. `thenAcceptAsync`

`thenAcceptAsync` 与 `thenAccept` 类似，也用于处理 `CompletableFuture` 计算的结果，但它是在异步线程中执行的。你可以指定一个线程池（`Executor`）来控制后续操作的执行，或者使用默认线程池。

```java
void thenAcceptAsync(Consumer<? super T> action);
void thenAcceptAsync(Consumer<? super T> action, Executor executor);
```

+ `action`：一个 `Consumer`，用于处理 `CompletableFuture` 完成时的结果。
+ `executor`（可选）：指定一个 `Executor` 来执行异步操作。如果未提供，默认使用 `ForkJoinPool.commonPool()`。

> [!danger] 警告
> `thenAcceptAsync` 是异步执行的，后续的处理会在另一个线程中执行，而不是阻塞当前线程。与 `thenAccept` 相比，`thenAcceptAsync` 允许你将操作委托给一个线程池来执行，避免主线程的阻塞。

```java
import java.util.concurrent.CompletableFuture; 
import java.util.concurrent.ExecutorService; 
import java.util.concurrent.Executors; 

public class ThenAcceptAsyncExample { 
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2); 
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
        future.thenAcceptAsync(value -> System.out.println("Async Result: " + value), executor);
        // 异步执行，输出: Async Result: 5
        executor.shutdown(); 
    }
}
```

### 3.3. `thenRun`<font style="color:rgb(79, 79, 79);">和</font>`thenRunAsync`

`thenRun` 和 `thenRunAsync`用于在异步任务完成后执行某些操作。不关心前一个任务的结果，执行一个新的任务（`Runnable`），但**不接受参数，也不返回结果**。

#### 3.3.1. `thenRun`

`thenRun` 方法用于在 `CompletableFuture` 完成后执行一个没有参数的操作。与 `thenAccept` 相似，`thenRun` 也不会返回任何结果。它是同步执行的，即操作会在当前线程中执行，直到完成。  

```java
CompletableFuture<Void> thenRun(Runnable action); 
```

+ `action`：一个 `Runnable`，它表示在 `CompletableFuture` 完成后执行的操作。

> [!danger] 警告
> `thenRun` 是同步执行的，后续的操作会在当前线程中执行，并且不会返回任何值。该方法适用于你只关心某个异步任务完成后要做一些额外操作，但不需要使用异步任务的结果。

```java
public class ThenRunExample {  
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
        future.thenRun(() -> System.out.println("Task Completed!"));  
        // 输出: Task Completed!
    }
}
```

#### 3.3.2. `thenRunAsync`

`thenRunAsync` 方法与 `thenRun` 类似，但它是在异步线程中执行的。它会将 `Runnable` 操作提交到一个线程池中去执行，从而避免阻塞当前线程。你还可以指定一个自定义的 `Executor` 来控制操作的执行方式。  

```java
CompletableFuture<Void> thenRunAsync(Runnable action);   
CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor);   
```

+ `action`：一个 `Runnable`，表示在 `CompletableFuture` 完成后执行的操作。
+ `executor`（可选）：一个 `Executor`，用于指定在哪个线程池中执行该操作。如果不指定，则使用 `ForkJoinPool.commonPool()` 作为默认线程池。

> [!danger] 警告
>
`thenRunAsync` 是异步执行的，后续操作会在独立的线程中执行，避免了当前线程的阻塞。可以通过 `Executor` 指定任务执行的线程池，这为并发操作提供了更高的灵活性。

```java
public class ThenRunAsyncExample { 
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2); 
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
        future.thenRunAsync(() -> System.out.println("Task Completed Asynchronously!"), executor);
        // 输出: Task Completed Asynchronously!
        executor.shutdown(); 
    }
}
```

### 3.4. `whenComplete` 和 `whenCompleteAsync` 

`whenComplete` 和 `whenCompleteAsync` 用于在 `CompletableFuture` 执行完成后进行回调处理，无论是成功还是异常，它们都会执行相应的回调逻辑。 

#### 3.4.1. `whenComplete`

`whenComplete` 方法用于在 `CompletableFuture` 执行完成后进行回调处理。无论任务是正常完成还是抛出异常，`whenComplete` 方法都会被执行。它在 **当前线程**（即执行 `CompletableFuture` 任务的线程）中执行。  

```java
CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action);
```

`action`：一个 `BiConsumer<T, Throwable>`，接受两个参数：
+ `T`：`CompletableFuture` 任务的计算结果（如果成功）。
+ `Throwable`：如果任务抛出异常，则该参数为异常，否则为 `null`。

> [!danger] 警告
>
`whenComplete`**不会改变**`CompletableFuture` 的计算结果，它只是一个回调，不会影响原有的 `CompletableFuture`。
**同步执行**，如果前面的任务已经完成，则 `whenComplete` 也会立即执行。

```java
public class WhenCompleteExample { 
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) { 
                throw new RuntimeException("Something went wrong!"); 
            }
            return 10; 
        });
        future.whenComplete((result, exception) -> { 
            if (exception != null) { 
                System.out.println("Execution failed: " + exception.getMessage()); 
            } else { 
                System.out.println("Execution successful: " + result); 
            }
        });
    }
}
```

#### 3.4.2. `whenCompleteAsync`

`whenCompleteAsync` 与 `whenComplete` 的主要区别在于它是 **异步执行的**，即 `whenCompleteAsync` 会将回调逻辑交给 **线程池**（默认是 `ForkJoinPool.commonPool()`），而不会在当前线程执行。

```java
CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action);
CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action, Executor executor);
```

+ `action`：与 `whenComplete` 相同的 `BiConsumer<T, Throwable>`，用于处理成功或失败的结果。
+ `executor`（可选）：可以传入一个 `Executor` 线程池，让回调任务在指定线程池中执行。

> [!danger] 警告
>
`whenCompleteAsync`**不会影响** 原有 `CompletableFuture` 的计算结果，它只是用于在任务完成后执行一些额外的逻辑。
**异步执行**，即使 `CompletableFuture` 任务已经完成，`whenCompleteAsync` 也不会立即执行，而是交给线程池去执行。

```java
public class WhenCompleteAsyncExample { 
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2); 
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) { 
                throw new RuntimeException("Something went wrong!"); 
            }
            return 10; 
        });
        future.whenCompleteAsync((result, exception) -> { 
            if (exception != null) { 
                System.out.println("Async Execution failed: " + exception.getMessage());
            } else {  
                System.out.println("Async Execution successful: " + result);
            }
        }, executor);  
        executor.shutdown();  
    }
}
```

### 3.5. `handle` 和 `handleAsync`

`handle` 和 `handleAsync` 类似 `whenComplete`，但 **可以修改返回值**，不管是否发生异常，都会执行。

#### 3.5.1. `handle`  

`handle` 方法用于在 `CompletableFuture` 完成时，处理任务的结果或者异常。与 `whenComplete` 类似，`handle` 也可以处理 `CompletableFuture` 任务的成功结果或者异常，但不同之处在于 `handle` 会返回一个新的 `CompletableFuture`。  

```java
<U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);
```

`fn`：一个 `BiFunction<T, Throwable, U>`，它接受两个参数：
+ `T`：`CompletableFuture` 的计算结果（如果任务成功）。
+ `Throwable`：如果任务失败，`Throwable` 为异常，成功则为 `null`。
+ 返回值 `U` 是你想要返回的新的计算结果。

> [!danger] 警告
>
`handle` 会在 `CompletableFuture` 执行完成后执行，且可以同时处理成功结果和异常。
`handle` 会返回一个新的 `CompletableFuture`，可以继续链式调用。
`handle` 不仅能处理成功结果，也能处理异常，并且可以改变返回值（通过返回新的结果）。

```java
public class HandleExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Something went wrong!");
            }
            return 10;
        });

        CompletableFuture<String> handled = future.handle((result, exception) -> {
            if (exception != null) {
                return "Error: " + exception.getMessage();
            } else {
                return "Success: " + result;
            }
        });
        handled.thenAccept(System.out::println);
    }
}
```

#### 3.5.2. `handleAsync`  

`handleAsync` 是 `handle` 的异步版本，表示在任务完成后，回调操作将**在另一个线程**中异步执行。这使得它在不阻塞当前线程的情况下处理任务的结果或异常。与 `handle` 不同，`handleAsync` 的回调逻辑是异步执行的。  

```java
<U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);
<U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn, Executor executor);
```

+ `fn`：一个 `BiFunction<T, Throwable, U>`，用于处理结果或异常，和 `handle` 中的 `fn` 一样。
+ `executor`（可选）：一个 `Executor`，用于指定在哪个线程池中执行 `fn` 操作。如果不指定，默认使用 `ForkJoinPool.commonPool()`。

> [!danger] 警告
>
`handleAsync` 是异步执行的，它会将回调函数提交给一个线程池执行，而不是阻塞当前线程。
如果没有提供 `executor`，默认使用 `ForkJoinPool.commonPool()` 来执行异步操作。
`handleAsync` 允许你在特定的线程池中执行回调函数，可以更好地控制异步任务的执行环境。

```java
public class HandleAsyncExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Something went wrong!");
            }
            return 10;
        });
        CompletableFuture<String> handled = future.handleAsync((result, exception) -> {
            if (exception != null) {
                return "Error: " + exception.getMessage();
            } else {
                return "Success: " + result;
            }
        }, executor);
        handled.thenAccept(System.out::println);
        executor.shutdown();
    }
}
```

## 4. 多任务组合处理 

在实际开发中，往往需要同时处理多个异步任务，或者让某些任务依赖于其他任务的结果。`CompletableFuture` 提供了 **组合操作** 模块，用于管理多个异步任务之间的关系，使复杂的异步流程更加清晰和高效。

常用的组合操作有：

1. **任务依赖组合**：使用 `thenCompose(Function)`，可以在一个异步任务完成后，继续执行另一个异步任务，实现链式依赖。
    
2. **结果合并**：使用 `thenCombine(CompletableFuture, BiFunction)`，可以在两个独立异步任务完成后，将结果合并处理。
    
3. **多任务并行**：使用 `allOf` 等待多个任务全部完成，或者使用 `anyOf` 等待任意一个任务完成。
    

通过组合操作模块，你可以轻松实现异步任务的依赖、合并和并行执行，使复杂业务逻辑的异步实现变得简洁、直观，并且易于维护。

### 4.1. `thenCombine`<font style="color:rgb(79, 79, 79);">、</font>`thenAcceptBoth`<font style="color:rgb(79, 79, 79);">和</font>`runAfterBoth`

它们主要用于组合两个 `CompletableFuture` 并在两个任务都完成后执行相应的操作。它们的主要区别在于结果的处理方式。

#### 4.1.1. `thenCombine`

当两个 `CompletableFuture` 都完成后，合并它们的结果，并返回一个新的 `CompletableFuture`。

```java
public <U, V> CompletableFuture<V> thenCombine(
    CompletionStage<U> other, 
    BiFunction<? super T, ? super U, ? extends V> fn
)
```

+ 另一个 `CompletableFuture<U>`。
+ 一个 `BiFunction<T, U, R>`，用于合并两个结果并返回一个新的值。

```java
public class ThenCombineExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);
        CompletableFuture<Integer> resultFuture = future1.thenCombine(future2, (a, b) -> a + b);
        System.out.println(resultFuture.join()); // 输出：30
    }
}
```

#### 4.1.2. `thenAcceptBoth`

合并两个 `CompletableFuture` 的结果，但不返回新的 `CompletableFuture`，仅执行一个 `Consumer` 操作。

```java
public <U> CompletableFuture<Void> thenAcceptBoth(
    CompletionStage<U> other, 
    BiConsumer<? super T, ? super U> action
)
```

+ `other`：另一个 `CompletableFuture`
+ `action`：一个消费两个 `CompletableFuture` 结果的操作

```java
public class ThenAcceptBothExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);
        future1.thenAcceptBoth(future2, (a, b) -> 
            System.out.println("Sum: " + (a + b))
        ).join(); // 确保主线程等待
        // 输出: Sum: 30
    }
}
```

#### 4.1.3. `runAfterBoth`

在两个 `CompletableFuture` 完成后执行一个 `Runnable` 任务，但不会使用它们的结果。

```java
public CompletableFuture<Void> runAfterBoth(
    CompletionStage<?> other, 
    Runnable action
)
```

+ `other`：另一个 `CompletableFuture`
+ `action`：在两个 `CompletableFuture` 完成后执行的 `Runnable` 任务

```java
public class RunAfterBothExample { 
    public static void main(String[] args) {

        CompletableFuture<Void> future1 = CompletableFuture.runAsync(() -> {

            System.out.println("Task 1 completed"); 
        });
        CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {

            System.out.println("Task 2 completed"); 
        });
        future1.runAfterBoth(future2, () ->  
            System.out.println("Both tasks completed") 
        ).join(); // 确保主线程等待

        // 可能输出：

        // Task 1 completed 
        // Task 2 completed 
        // Both tasks completed 
    }
}
```

| 方法 | 作用 | 结果类型 | 适用场景 |
| --- | --- | --- | --- |
| `thenCombine` | 合并两个 `CompletableFuture`结果并返回新结果 | `CompletableFuture<V>` | 需要返回计算后的新值 |
| `thenAcceptBoth` | 处理两个 `CompletableFuture`结果但不返回新结果 | `CompletableFuture<Void>` | 仅处理结果，无需返回 |
| `runAfterBoth` | 在两个 `CompletableFuture`结束后执行任务，不接收结果 | `CompletableFuture<Void>` | 仅执行任务，无需处理结果 |

### 4.2. `applyToEither`<font style="color:rgb(79, 79, 79);">、</font>`acceptEither`和`runAfterEither`

`applyToEither`、`acceptEither` 和 `runAfterEither` 用于在**两个 **`**CompletableFuture**`** 中最先完成的一个**完成时执行操作。

> `applyToEither`：对**先完成**的结果进行转换，并返回新的 `CompletableFuture`。
>
> `acceptEither`：对**先完成**的结果进行消费，但**不返回结果**。
>
> `runAfterEither`：不使用任何结果，仅在**任意一个完成**时执行 `Runnable` 任务。
>

#### 4.2.1. `applyToEither`

使用**最先完成**的 `CompletableFuture` 结果进行计算，并返回一个新的 `CompletableFuture`。

```java
public <U> CompletableFuture<U> applyToEither(
    CompletionStage<? extends T> other, 
    Function<? super T, U> fn
)
```

+ `other`：另一个 `CompletableFuture`
+ `fn`：一个**转换函数**，用于处理最先完成的结果，并返回新的值。

```java
public class ApplyToEitherExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000); // 模拟 1 秒后完成
            return 10;
        });
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(500); // 模拟 0.5 秒后完成
            return 20;
        });
        CompletableFuture<Integer> result = future1.applyToEither(future2, value -> value * 2);
        System.out.println(result.join()); // 输出 40（因为 future2 先完成，20 * 2）
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```

#### 4.2.2. `acceptEither`

使用**最先完成**的 `CompletableFuture` 结果执行 `Consumer` 任务，但**不返回结果**。

```java
public CompletableFuture<Void> acceptEither(
    CompletionStage<? extends T> other, 
    Consumer<? super T> action
)
```

+ `other`：另一个 `CompletableFuture`
+ `action`：用于消费最先完成的 `CompletableFuture` 结果的 `Consumer` 操作。

```java
public class AcceptEitherExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000); // 1 秒后完成
            return 10;
        });
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(500); // 0.5 秒后完成
            return 20;
        });
        future1.acceptEither(future2, value -> 
            System.out.println("First completed result: " + value)
        ).join(); // 确保主线程等待
        // 输出: First completed result: 20
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```

#### 4.2.3. `runAfterEither`

在任意一个 `CompletableFuture`任务完成后执行 `Runnable` 任务，不接受结果。

```java
public CompletableFuture<Void> runAfterEither(
    CompletionStage<?> other, 
    Runnable action
)
```

+ `other`：另一个 `CompletableFuture`
+ `action`：在任意一个 `CompletableFuture` 任务完成后执行的 `Runnable` 任务。

```java
public class RunAfterEitherExample {
    public static void main(String[] args) {
        CompletableFuture<Void> future1 = CompletableFuture.runAsync(() -> {
            sleep(1000); // 1 秒后完成
            System.out.println("Task 1 completed");
        });
        CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {
            sleep(500); // 0.5 秒后完成
            System.out.println("Task 2 completed");
        });
        future1.runAfterEither(future2, () -> 
            System.out.println("One of the tasks has completed")
        ).join(); // 确保主线程等待
        // 可能输出：
        // Task 2 completed
        // One of the tasks has completed
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```

| 方法 | 作用 | 结果类型 | 适用场景 |
| --- | --- | --- | --- |
| `applyToEither` | 使用最先完成的 `CompletableFuture`结果计算新值 | `CompletableFuture<U>` | 需要返回新值 |
| `acceptEither` | 使用最先完成的 `CompletableFuture`结果执行操作，不返回值 | `CompletableFuture<Void>` | 仅消费结果，无需返回 |
| `runAfterEither` | 只要有一个 `CompletableFuture`完成，就执行 `Runnable`任务 | `CompletableFuture<Void>` | 仅执行任务，不关心结果 |

### 4.3. `allOf`和`anyOf`

`allOf`等待**所有**`CompletableFuture` 任务完成后再执行后续操作，`anyOf`**任意一个**`CompletableFuture` 任务完成后就执行后续操作。

#### 4.3.1. `allOf`

等待**所有**`CompletableFuture` 任务完成后执行后续操作，但**不会返回结果**。

```java
public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)
```

+ `cfs`：可变参数，表示多个 `CompletableFuture` 任务。

```java
public class AllOfExample {
    public static void main(String[] args) {
        List<CompletableFuture<Integer>> futures = IntStream.range(1, 6)
            .mapToObj(i -> CompletableFuture.supplyAsync(() -> {
                sleep(i * 500);
                System.out.println("Task " + i + " completed");
                return i;
            }))
            .collect(Collectors.toList());
        CompletableFuture<Void> allDoneFuture = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        );
        allDoneFuture.join(); // 等待所有任务完成
        System.out.println("All tasks completed");
        // 获取所有结果
        List<Integer> results = futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());
        System.out.println("Results: " + results);
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```

#### 4.3.2. `anyOf`

**任意一个**`CompletableFuture` 任务完成后就执行后续操作，并返回该任务的结果。

```java
public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)
```

+ `cfs`：可变参数，表示多个 `CompletableFuture` 任务。

```java
public class AnyOfExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return 10;
        });
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(500);
            return 20;
        });
        CompletableFuture<Integer> future3 = CompletableFuture.supplyAsync(() -> {
            sleep(2000);
            return 30;
        });
        CompletableFuture<Object> firstCompleted = CompletableFuture.anyOf(future1, future2, future3);
        System.out.println("First completed result: " + firstCompleted.join());
        // 可能输出：First completed result: 20（因为 future2 先完成）
    }
    private static void sleep(int ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
```



