---
title: 1. 多线程基础33
category: 并发
tags:
  - 多线程
published: 2022-08-10
updated: 2022-08-10
draft: true
---

在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现`Runnable`接口，就可以让线程池去执行。

```java
class Task implements Runnable {
    public String result;

    public void run() {
        this.result = longTimeCalculation(); 
    }
}
```

`Runnable`接口有个问题，它的方法**没有返回值**。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个`Callable`接口，和`Runnable`接口比，它多了一个返回值。

```java
class Task implements Callable<String> {
    public String call() throws Exception {
        return longTimeCalculation(); 
    }
}
```

并且`Callable`接口是一个**泛型接口**，可以返回指定类型的结果。

现在的问题是，如何获得异步执行的结果？

如果仔细看`ExecutorService.submit()`方法，可以看到，它返回了一个`Future`类型，一个`Future`类型的实例代表一个未来能获取结果的对象：

```java
ExecutorService executor = Executors.newFixedThreadPool(4); 
// 定义任务
Callable<String> task = new Task();
// 提交任务并获得Future
Future<String> future = executor.submit(task);
// 从Future获取异步执行返回的结果
String result = future.get(); // 可能阻塞
```

当我们提交一个`Callable`任务后，我们会同时获得一个`Future`对象，然后，我们在主线程某个时刻调用`Future`对象的`get()`方法，就可以获得异步执行的结果。

**<font style="background-color:rgb(254,234,210);">在调用</font>**`**<font style="background-color:rgb(254,234,210);">get()</font>**`**<font style="background-color:rgb(254,234,210);">时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么</font>**`**<font style="background-color:rgb(254,234,210);">get()</font>**`**<font style="background-color:rgb(254,234,210);">会阻塞，直到任务完成后才返回结果。</font>**

```java
public class FutureExample {
    public static void main(String[] args){
        // 使用ThreadPoolExecutor创建线程池，阿里巴巴规范。
        ExecutorService es = new ThreadPoolExecutor(3, 5, 1, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
        try{
            for (int i = 0; i < 10; i++){
                Random random = new Random();
                Callable<String> task = new Task(random.nextInt(1000000));
                Future<String> future = es.submit(task);
                String result = future.get();
                System.out.println(result);
            }
            es.shutdown();
        }catch (InterruptedException | ExecutionException e){
            System.out.println("InterruptedException Or ExecutionException");
            es.shutdownNow();
        }catch (Exception e){
            System.out.println("Exception");
            es.shutdownNow();
        }finally {
            es.shutdownNow();
        }
    }
}

class Task implements Callable<String> {

    private Integer number;

    Task(Integer number){
        this.number = number;
    }
    @Override
    public String call() {
        Thread.currentThread().setName(number+"以内的水仙数为：");
        StringBuilder result = new StringBuilder();
        for (int i = 1; i <= number; i++){
            if (isNarcissisticNumber(i)){
                result.append(i).append("\t");
            }
        }
        return Thread.currentThread().getName() + result.toString();
    }

    private boolean isNarcissisticNumber(int number){
        int originalNumber = number;
        int digits = (int)Math.log10(number) + 1;
        //int digits = String.valueOf(number).length(); // 计算数字的位数
        int sum = 0;
        while (number > 0){
            int digit = number % 10;
            sum += Math.pow(digit, digits);
            number /= 10;
        }
        return sum == originalNumber;
    }
}

```

一个`**<font style="background-color:rgb(251,191,188);">Future<V></font>**`接口表示一个未来可能会返回的结果，它定义的方法有：

+ `**get()**`：获取结果（可能会等待）
+ `**get(long timeout, TimeUnit unit)**`：获取结果，但只等待指定的时间；
+ `**cancel(boolean mayInterruptIfRunning)**`：取消当前任务；
+ `**isDone()**`：判断任务是否已完成。

