---
title: 1. 多线程基础6
category: 并发
tags:
  - 多线程
published: 2022-08-10
updated: 2022-08-10
draft: true
---

虚拟线程是Java 19引入的，作为Project Loom的一部分。在此之前Java的线程模型一直是平台线程，也就是操作系统线程，每个线程对应一个OS线程，这样在高并发的时候可能会有资源限制，因为OS线程太重量级了，创建太多的话会消耗大量内存和CPU资源。

那虚拟线程的出现就是为了解决这个问题，让开发者能够轻松创建数百万个线程而不用担心资源耗尽。虚拟线程是由JVM管理的轻量级线程，这样它们可以在用户空间中进行调度，减少对OS线程的依赖。这样的话，应用可以处理更多的并发任务，特别是在I/O密集型场景下，比如网络请求或者文件操作，因为虚拟线程在等待I/O的时候可以挂起，让出载体线程去执行其他任务，这样就能更高效地利用资源。

## **<font style="color:rgb(64, 64, 64);">虚拟线程的核心概念</font>**
1. **<font style="color:rgb(64, 64, 64);">轻量级线程</font>**<font style="color:rgb(64, 64, 64);">：虚拟线程由 JVM 直接管理，而非操作系统（OS），创建和切换成本极低。</font>
2. **<font style="color:rgb(64, 64, 64);">M:N 调度模型</font>**<font style="color:rgb(64, 64, 64);">：多个虚拟线程（M）映射到少量 OS 线程（N）上运行，突破了传统平台线程（1:1 模型）的资源限制。</font>
3. **<font style="color:rgb(64, 64, 64);">非绑定 OS 线程</font>**<font style="color:rgb(64, 64, 64);">：虚拟线程在执行阻塞操作（如 I/O）时，会自动挂起并释放底层 OS 线程（称为“载体线程”），从而高效利用硬件资源。</font>

## **<font style="color:rgb(64, 64, 64);">与平台线程的区别</font>**
| **特性** | **平台线程** | **虚拟线程** |
| --- | --- | --- |
| **<font style="color:rgb(64, 64, 64);">资源开销</font>** | <font style="color:rgb(64, 64, 64);">高（MB 级内存/线程）</font> | <font style="color:rgb(64, 64, 64);">极低（KB 级内存/线程）</font> |
| **<font style="color:rgb(64, 64, 64);">创建数量上限</font>** | <font style="color:rgb(64, 64, 64);">通常数百至数千</font> | <font style="color:rgb(64, 64, 64);">轻松支持数百万个</font> |
| **<font style="color:rgb(64, 64, 64);">调度机制</font>** | <font style="color:rgb(64, 64, 64);">由 OS 内核调度</font> | <font style="color:rgb(64, 64, 64);">由 JVM 调度（协作式）</font> |
| **<font style="color:rgb(64, 64, 64);">适用场景</font>** | <font style="color:rgb(64, 64, 64);">CPU 密集型任务</font> | <font style="color:rgb(64, 64, 64);">I/O 密集型或高阻塞任务</font> |


## 使用虚拟线程
### 创建单个虚拟线程
```java
public class VirtualThreadExample {
    public static void main(String[] args) {
        Thread virtualThread = Thread.ofVirtual().start(() -> {
            System.out.println("虚拟线程运行: " + Thread.currentThread());
        });

        try {
            virtualThread.join(); // 等待虚拟线程执行完成
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

> **Java 19 及以上版本**，可以使用 `Thread.ofVirtual()` 创建虚拟线程。
>

### 创建大量虚拟线程
```java
public class MassVirtualThreads {
    public static void main(String[] args) {
        try (var executor = java.util.concurrent.Executors.newVirtualThreadPerTaskExecutor()) {
            for (int i = 0; i < 100000; i++) {
                int taskId = i;
                executor.submit(() -> {
                    System.out.println("Task " + taskId + " running on: " + Thread.currentThread());
                });
            }
        } // executor 关闭时，虚拟线程自动清理
    }
}
```

> 注意： `**<font style="color:#74B602;">Executors.newVirtualThreadPerTaskExecutor()</font>**` 是 Java 21 推荐的方式，它会为每个任务创建一个新的虚拟线程，并自动管理它们。
>

## 虚拟线程**调度机制**
1. **虚拟线程不会绑定固定的 OS 线程**。

> 运行时，它们会由 **ForkJoinPool** 进行调度（一个轻量级的线程池）。
>
> 任务执行时，虚拟线程会借用 **少量 OS 线程**（通常 1:10,000 的比例）。
>

2. **阻塞不会导致 OS 线程浪费**。

> 如果一个虚拟线程 **执行阻塞操作**（如 `Thread.sleep()` 或数据库查询），JVM 会 **自动把它暂停**，释放 OS 线程。
>
> 当阻塞结束后，JVM **恢复** 该虚拟线程到另一个可用的 OS 线程上执行。
>

## 虚拟线程的局限性
1. **不适合 CPU 密集型任务**

> 虚拟线程主要适用于 **I/O 密集型任务**，如网络请求、数据库操作等。
>
> 如果是 CPU 密集型计算，虚拟线程的优势并不明显，推荐使用固定线程池。
>

2. **不能修改 **`**ThreadLocal**`** 变量**（官方不推荐）

> 由于虚拟线程可能会在不同的 OS 线程之间切换，**ThreadLocal 可能会导致数据不一致**。
>
> 解决方案：尽量避免使用 `ThreadLocal`，改用参数传递或者 `ScopedValue`（Java 21 新增）。
>

---

