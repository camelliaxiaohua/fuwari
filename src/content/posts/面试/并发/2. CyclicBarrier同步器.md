---
title: 2. CyclicBarrier同步器
category: 并发
tags:
  - 线程同步
  - 多线程
published: 2025-09-02
updated: 2025-09-02
aliaes:
  - https://www.mianshiya.com/bank/1789249312885223425/question/1780933294938943489#heading-3
draft: false
---
---

`CyclicBarrier` 是 **Java 并发包** (`java.util.concurrent`) 里提供的一种 **同步工具类**，字面意思就是**可循环使用的栅栏**。

- **Barrier（栅栏）**：想象一群人要等齐了才能出发，大家都到齐之前，谁先到谁就要在栅栏这等着。
  
- **Cyclic（循环的）**：这个栅栏不是一次性的，用完后可以重置，下次还能再用。

### 1. 作用

让一组线程（数量固定）在某个屏障点 **相互等待**，直到所有线程都到达了这个屏障点，才会一起继续往下执行。

**典型场景：**

- 多个线程分阶段工作 → 在某个阶段必须等所有线程完成，才能进入下一阶段。
  
- 多线程任务需要“对齐”执行，例如并行计算、模拟赛跑、分布式任务合并结果。
  
假设有 5 个运动员（线程），他们要跑接力赛，必须等大家都到起点，裁判一声令下，才一起开跑。

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        int count = 5;

        // 定义一个栅栏，5个线程都到达后，执行barrierAction
        CyclicBarrier barrier = new CyclicBarrier(count, () -> {
            System.out.println("所有人到齐，比赛开始！");
        });

        for (int i = 1; i <= count; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    System.out.println("运动员 " + id + " 到达起点，等待中...");
                    barrier.await(); // 等待其他线程
                    System.out.println("运动员 " + id + " 开始跑步！");
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

运行结果（顺序可能不同）：

```
运动员 1 到达起点，等待中...
运动员 2 到达起点，等待中...
运动员 3 到达起点，等待中...
运动员 4 到达起点，等待中...
运动员 5 到达起点，等待中...
所有人到齐，比赛开始！
运动员 3 开始跑步！
运动员 5 开始跑步！
运动员 2 开始跑步！
运动员 1 开始跑步！
运动员 4 开始跑步！
```

### 2. 和 CountDownLatch 的区别

很多人容易混淆 `CyclicBarrier` 和 `CountDownLatch`：

| 特点        | `CyclicBarrier`   | `CountDownLatch`         |
| --------- | ----------------- | ------------------------ |
| **等待机制**  | 一组线程互相等待，直到都到齐    | 一个或多个线程等待，直到计数器归零        |
| **是否可复用** | **可复用**（循环使用）     | **一次性**，计数归零就报废          |
| **触发点**   | 所有线程都调用 `await()` | 主线程/工作线程调用 `countDown()` |

  