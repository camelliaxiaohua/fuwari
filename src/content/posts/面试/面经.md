---
title: 面经
category: 面试
tags:
  - 面试
published: 2026-01-29
updated: 2026-01-29
draft: true
---
---
## 1. Java基础

### · 序列化和反序列化是什么？

**序列化（Serialization）** 是将Java对象转换为字节序列（字节流）的过程，这样对象就可以被保存到文件、数据库中，或者通过网络传输。**反序列化（Deserialization）** 则是相反的过程，将字节序列（字节流）恢复为Java对象。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260129220900991.png" alt="image-20260129220900991" style="zoom: 33%;" />

1. **如何实现序列化？**

类必须实现`Serializable`接口，这个相当于一个许可证，没它 JDK 序列化机制不会让你序列化。

> 这接口是个空接口，一行代码都没有，纯粹就是个标记。JDK 序列化源码里有这么一段逻辑：除了 `String`、数组和枚举这几个特殊类型，其他对象要序列化必须实现 `Serializable`，否则直接抛 `NotSerializableException`。

2. **如何避免某些属性序列化？**

`transient` 关键字修饰的字段不会被序列化，序列化的时候会自动跳过。

> `transient` 字段在反序列化后，不是“保留旧值”，而是被赋成“类型的默认值”。

3. **如何保证序列化够稳？**

显式定义 `serialVersionUID`，相当于给类打个版本戳，防止改了类结构后反复序列化旧数据时报错。

> 这就等于你在说：“不管我内部怎么小改，只要我没手动改 `serialVersionUID`，就请你当成是同一个版本。”

> [!quote] 详情参考
> [[如何保证序列化够稳？]]

---

### · 对象为什么不能直接传输？

对象在内存中包含 对象数据（字段值）、内存地址引用、方法指针、虚拟方法表（vtable）等元数据，这些信息在不同的JVM进程中完全不同，无法直接复制。

无论是网络传输还是文件存储，底层只能处理连续的字节序列（byte stream），不理解Java对象的结构。

---

### · 静态变量参与序列化吗？

静态变量不参与序列化。

静态变量属于**类本身**，而不是对象实例。序列化是保存**对象的状态**，静态变量不是对象状态的一部分。反序列化后，静态变量的值**完全取决于当前JVM中类的静态变量值**，与序列化时的值无关。

---

### · 如果父类没有实现`Serializable`，子类实现了，序列化子类对象时父类对象会如何？

父类未实现 `Serializable` 时，序列化会"跳过"父类字段，反序列化时通过调用父类无参构造方法来初始化父类部分，所以父类字段会恢复为初始值而非序列化时的值。**如果父类没有无参构造方法，反序列化会直接失败，抛出 `InvalidClassException` 异常**。

---

### · JDK 序列化的问题

JDK 自带的序列化虽然用起来简单，但生产环境很少直接用，主要有这几个硬伤：

1. **性能差**：序列化后的字节流体积大，序列化/反序列化速度慢
2. **跨语言不友好**：只有 Java 能读懂，无法与 Go、Python 等语言直接互通
3. **安全风险**：存在反序列化漏洞，可能被恶意利用执行任意代码

所以实际项目中，RPC 框架一般用 Protobuf、Hessian、Kryo 这类专门的序列化框架，性能更好、体积更小。JSON 序列化虽然性能一般，但可读性好，在 HTTP API 场景中使用广泛。

|序列化方式|优点|缺点|典型场景|
|---|---|---|---|
|JDK 原生|使用简单|性能差、体积大、有安全风险|小项目、临时方案|
|JSON|可读性好、跨语言|性能一般、体积较大|HTTP API、配置文件|
|Protobuf|高性能、体积小|需要定义 .proto 文件|gRPC、高性能 RPC|
|Hessian|性能较好、使用简单|跨语言支持有限|Dubbo 默认序列化|
|Kryo|高性能、体积小|仅支持 Java|游戏服务器、缓存|

---

### · 为什么说反序列化是 Java 安全漏洞的重灾区？

反序列化会触发对象的构造过程，如果攻击者构造恶意的字节流，就能让某些类的特定方法被执行，从而造成远程代码执行（RCE）。

典型案例是利用 Apache Commons Collections、Fastjson 等库中的 **gadget chain**（利用链）。攻击者只需找到一条从反序列化入口通往危险方法（如 `Runtime.exec()`）的调用链，就能在服务器上执行任意命令，比如反弹 shell、读取敏感文件等。

**防御手段：**

1. **及时升级**：修复 Commons Collections、Fastjson 等已知存在漏洞的依赖库
2. **白名单机制**：配置反序列化白名单，只允许可信类进行反序列化
3. **替代方案**：使用 JSON、Protobuf 等更安全的序列化方式替代 Java 原生序列化
4. **网络隔离**：不直接暴露反序列化接口到公网

---
### · Java 中 Exception 和 Error 有什么区别?

`Exception` 和 `Error` 都是 `Throwable` 的子类，但它们的用途和处理方式完全不同。

> 只有继承了 `Throwable` 的对象才能被 `throw` 和 `catch`。

**Exception（异常）**

- **可预期的问题**，程序可以捕获并处理；
- 分为受检异常（`Checked Exception`）和非受检异常（`Unchecked Exception`）；
- 应该被 `try-catch` 捕获或通过 `throws` 声明。

> [!tip] 
> `Checked Exception`: 继承自 `Exception` 但不继承 `RuntimeException`，编译时必须显式处理，要么 `try-catch` 要么 `throws` 声明抛出，比如 `IOException`、`SQLException`。
> 
> `Unchecked Exception`: 继承自 `RuntimeException`，不需要显式捕获，运行时才抛出，比如 `NullPointerException`、`IndexOutOfBoundsException`。

**Error（错误）**

- **严重的系统级问题**，程序通常无法处理；
- 都是非受检的（继承自 `Error`）；
- 不应该被捕获，程序应该终止。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260130144522567.png" alt="image-20260130144522567" style="zoom: 33%;" />

---

### · 什么是Java多态特性？

多态（Polymorphism）是面向对象编程的三大特性之一（封装、继承、多态），指的是**同一个方法调用，在不同对象上会有不同的表现形式**。

> 简单来说：父类引用指向子类对象，调用方法时会执行子类的实现。

要实现多态，必须满足以下条件：

1. **继承关系**：子类继承父类或实现接口
	
2. **方法重写**：子类重写父类的方法
	
3. **父类引用指向子类对象**：向上转型

---

### · 编译时多态和运行时多态

**编译时多态（静态多态）**

通过**方法重载（Overload）** 实现，在编译阶段就能确定调用哪个方法。同一个类中，方法名相同，参数列表不同（参数个数、类型或顺序不同），编译器根据方法签名在编译时就能确定调用哪个方法，也叫**静态绑定**或**早期绑定**。

**运行时多态（动态多态）**

通过**方法重写（Override）** 实现，在运行时才能确定调用哪个方法。父类引用指向子类对象，子类重写父类的方法。运行时根据对象的实际类型决定调用哪个方法，也叫**动态绑定**或**晚期绑定**。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260130150850155.png" alt="image-20260130150850155" style="zoom: 50%;" />

---
### · 虚方法表的底层原理（简要概括）

虚方法表是 JVM 为每个类构建的方法地址索引表，用于实现运行时多态。当子类重写父类方法时，会在虚方法表的相同索引位置替换为自己的方法地址。多态调用时，JVM 根据对象的实际类型找到对应的虚方法表，通过索引直接定位方法地址并调用，实现 O(1) 的快速查找，这就是 Java 多态"运行时动态绑定"的底层实现机制。

> [!quote] 详情参考
> [[虚方法表的底层原理]]

---

### · Java中参数传递是值传递还是引用传递？

**Java 中只有值传递（Pass by Value），没有引用传递。**

- **值传递**：传递的是变量值的副本，修改副本不影响原变量。
- **引用传递**：传递的是变量本身的引用的副本（**内存地址值**），修改会影响原变量。

> **Java 的规则**：无论基本类型还是对象类型，传递的都是值的副本。

---
### · 基本类型与引用类型的区别？

**基本类型**包括 `byte`、`short`、`int`、`long`、`float`、`double`、`char`、`boolean` 共 8 种。作为局部变量时，基本类型的值直接存储在栈内存中；作为成员变量时，存储在堆内存的对象中。方法传参时传递的是值的副本，方法内的修改不影响原始变量。

**引用类型**包括类、接口、数组等。引用类型的变量存储的是对象在堆内存中的地址（引用值）。方法传参时传递的是地址值的副本，因此方法内可以通过这个副本引用修改对象的内容，但无法改变原引用变量指向的对象。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260201145710540.png" alt="image-20260201145710540" style="zoom: 50%;" />


> [!quote] 详情参考
> [[基本类型与引用类型在 JVM 存储位置]]

---

### · `String` 作为参数传递后在方法里修改了但为什么原来的变量没变？

`String` 是不可变类，方法里对 `String` 做任何拼接或替换操作，实际上是创建了一个新的 `String` 对象，然后让方法内的局部引用指向这个新对象。原来的引用还是指向老对象，压根没动过。这不是传引用还是传值的问题，而是 `String` 本身的不可变性决定的。

> [!quote] 详情参考
> [[Java中的不可变类]]

---
### · 为何Java不支持多重继承？

Java不支持多重继承主要是为了避免**菱形继承问题**。当一个类同时继承两个父类，而这两个父类又继承自同一个祖先类时，子类会面临方法调用歧义、字段重复、构造顺序混乱等问题。C++允许多重继承但把这些复杂性留给程序员处理，Java则选择了更简洁的方案：**单继承加多接口实现**。这样既保持了继承链的清晰，又通过接口获得了多态能力。Java 8引入接口默认方法后虽然也可能产生冲突，但编译器会强制开发者显式解决，而非隐式选择。这是Java在灵活性和简单性之间做出的刻意取舍。

> [!quote] 参考
> [[Java为何不支持多重继承]]

---

### · 方法重载和方法重写之间的区别

**方法重载（Overloading）** 是在同一个类中定义多个同名方法，但参数列表不同（参数类型、个数或顺序）。编译器在编译期根据调用时传入的参数类型决定调用哪个方法，属于**编译时多态**。重载与返回值类型无关，仅靠返回值不同无法构成重载。

```java
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
}
```

**方法重写（Overriding）** 是子类重新定义父类中已有的方法，要求方法签名完全相同（方法名、参数列表一致），**返回值类型相同或是父类返回值的子类型**。JVM在运行时根据对象的实际类型决定调用哪个版本，属于**运行时多态**。重写的**方法访问权限不能比父类更严格**，**抛出的异常不能比父类更宽泛**。

```java
class Animal {
    void speak() { System.out.println("..."); }
}

class Dog extends Animal {
    @Override
    void speak() { System.out.println("汪汪"); }
}
```

简单来说，重载是**横向扩展**同一个类的方法能力，重写是**纵向覆盖**父类的行为实现。重载发生在编译期、同一类内，重写发生在运行期、父子类之间。

---

### · 为何静态方法不能被重写？

*静态方法属于类本身而非对象实例，它在编译期就根据引用类型确定了调用哪个方法，这与重写所依赖的运行时多态机制相矛盾。* 重写的本质是子类对象在运行时根据实际类型动态选择方法实现，而静态方法的调用不依赖任何对象，自然无法参与这种动态绑定。当子类定义了与父类签名相同的静态方法时，这只是 **方法隐藏（Method Hiding）** 而非重写——父类的静态方法并没有被覆盖，两个方法各自独立存在于各自的类中，调用哪个完全取决于编译时的引用类型。

```java
class Parent {
    static void hello() { System.out.println("Parent"); }
}

class Child extends Parent {
    static void hello() { System.out.println("Child"); }
}

Parent p = new Child();
p.hello();  // 输出 "Parent"，而非 "Child"
```

如果这是真正的重写，应该输出"Child"，但实际输出"Parent"，因为编译器只看到`p`的类型是`Parent`就直接绑定了`Parent.hello()`。这也是为什么IDE会建议用类名而非实例来调用静态方法——静态方法本就与对象无关，通过实例调用反而容易造成误解。

---

### · 方法重载时传入`null`会调用哪个方法？

当重载方法都能接受null时，编译器会选择**参数类型最具体**的那个方法。

```java
void test(Object obj) { System.out.println("Object"); }
void test(String str) { System.out.println("String"); }

test(null);  // 输出 "String"
```

因为String是Object的子类，类型更具体，所以编译器选择了String版本。

但如果存在两个同级别的类型，编译器无法判断谁更具体，就会报错：

```java
void test(String str) { System.out.println("String"); }
void test(Integer num) { System.out.println("Integer"); }

test(null);  // 编译错误：引用不明确
```

String和Integer没有继承关系，编译器无法抉择。解决办法是显式转型告诉编译器你的意图：

```java
test((String) null);   // 输出 "String"
test((Integer) null);  // 输出 "Integer"
```

这个行为的本质是Java的**最具体匹配原则**：编译器在所有可行的重载方法中，选择参数类型在继承层次上最接近实参类型的那个。null可以赋值给任何引用类型，所以所有接受引用类型的重载都可行，最终选择类型层次最深的那个。

---

### · 什么是内部类

内部类是定义在另一个类内部的类，它可以访问外部类的成员（包括私有成员），用于实现更紧密的封装和逻辑组织。Java有四种内部类：

- **成员内部类**

定义在外部类的成员位置，不带`static`修饰，与实例字段平级，可以访问外部类的所有成员变量，包括`private`。它**持有外部类实例的引用**，必须依附于外部类对象存在。

```java
class Outer {
    private String name = "外部类";
    
    class Inner {
        void show() {
            System.out.println(name);  // 可访问外部类私有成员
        }
    }
}

// 创建方式
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
```

- **静态内部类**

用`static`修饰的内部类，不持有外部类实例的引用，只能访问外部类的静态成员。它本质上是一个独立的类，只是命名空间嵌套在外部类中。

```java
class Outer {
    private static String staticName = "静态成员";
    
    static class StaticInner {
        void show() {
            System.out.println(staticName);  // 只能访问静态成员
        }
    }
}

// 创建方式，不依赖外部类实例
Outer.StaticInner inner = new Outer.StaticInner();
```

- **局部内部类**

定义在方法或代码块内部，作用域仅限于该方法或代码块。它可以访问外部类成员和所在方法的局部变量（必须是`final`或 等效`final`）。

```java
class Outer {
    void doSomething() {
        final int count = 10;
        
        class LocalInner {
            void show() {
                System.out.println(count);
            }
        }
        
        new LocalInner().show();
    }
}
```

- **匿名内部类**

没有名字的局部内部类，用于快速实现接口或继承类，常见于回调和事件处理。

```java
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("按钮被点击");
    }
});
```

Java 8之后，函数式接口的匿名内部类可以用Lambda简化：

```java
button.addActionListener(e -> System.out.println("按钮被点击"));
```

|类型|能否访问外部类实例成员|创建方式|典型用途|
|---|---|---|---|
|成员内部类|能|依赖外部类实例|紧密关联的辅助类|
|静态内部类|不能（只能访问静态成员）|独立创建|Builder模式、逻辑分组|
|局部内部类|能|方法内部使用|临时封装逻辑|
|匿名内部类|能|声明同时实例化|回调、事件监听|

---

### · 内部类的底层实现

内部类是Java语言层面的特性，JVM本身并不认识内部类。编译器会将内部类编译成独立的class文件，并通过一些机制来维持内部类与外部类之间的关系。

- **成员内部类**

编译后会生成`Outer$Inner.class`文件，编译器自动为内部类添加一个指向外部类实例的引用字段和相应的构造器参数。

```java
class Outer {
    private String name = "外部类";
    
    class Inner {
        void show() {
            System.out.println(name);
        }
    }
}
```

编译器实际生成的内部类大致等价于：

```java
class Outer$Inner {
    final Outer this$0;  // 编译器自动添加的外部类引用
    
    Outer$Inner(Outer outer) {
        this.this$0 = outer;
    }
    
    void show() {
        System.out.println(this$0.name);
    }
}
```

访问外部类私有成员时，编译器会在外部类中生成合成的访问方法（synthetic method）：

```java
class Outer {
    private String name;
    
    // 编译器生成的桥接方法
    static String access$000(Outer outer) {
        return outer.name;
    }
}
```

- **静态内部类**

同样生成独立的class文件，但由于没有外部类实例引用，结构更简单，和普通类几乎一样，只是类名带有`Outer$StaticInner`的前缀。

```java
class Outer$StaticInner {
    // 没有this$0字段
    // 就是一个普通类
}
```

- **局部内部类**

编译后生成`Outer$1LocalInner.class`，数字用于区分同名局部类。它捕获的局部变量会被复制为内部类的字段：

```java
void doSomething() {
    final int count = 10;
    
    class LocalInner {
        void show() {
            System.out.println(count);
        }
    }
}
```

实际编译为：

```java
class Outer$1LocalInner {
    final Outer this$0;
    final int val$count;  // 捕获的局部变量副本
    
    Outer$1LocalInner(Outer outer, int count) {
        this.this$0 = outer;
        this.val$count = count;
    }
}
```

这就是为什么被捕获的局部变量必须是final或等效final——内部类持有的是变量值的副本，如果原变量能修改，两边数据就不一致了。

- **匿名内部类**

编译后生成`Outer$1.class`、`Outer$2.class`等，按出现顺序编号。本质和局部内部类相同，只是没有显式类名。

---

### · 成员内部类和静态内部类如何选？

如果内部类需要访问外部类的实例成员，就用成员内部类；如果不需要，优先用静态内部类。原因很简单，成员内部类会隐式持有外部类的引用，可能导致外部类无法被 GC 回收，造成内存泄漏。Android 开发里的 Handler 内存泄漏就是典型案例。

---
### · 匿名内部类访问局部变量为什么必须是`final`？

因为匿名内部类和局部变量的生命周期不同。局部变量存在于栈上，方法执行结束就销毁了；但匿名内部类的实例可能在方法结束后仍然存活，比如作为回调被其他对象持有。为了让内部类在方法结束后还能访问这个变量，编译器会在内部类中创建一个字段来保存该变量值的副本。

既然是副本，就存在数据一致性问题——如果允许修改原变量，内部类中的副本不会同步更新，两边数据就不一致了。Java选择通过强制final来从源头避免这个问题：变量不可变，副本就永远和原值一致。

Java 8之后不再要求显式写final，但变量必须是"等效final"，即实际上没有被修改过。这只是语法上的放宽，底层机制完全一样。

---
### · Java中String、StringBuffer、StringBuilder 的区别是什么？

**String** 是不可变类，底层的`char`数组被`final`修饰，每次修改都会创建新对象。它线程安全，适合字符串常量或很少修改的场景。

**StringBuilder** 是可变的字符序列，修改操作直接在原对象上进行，不创建新对象。它不是线程安全的，但性能最好，适合**单线程**下频繁拼接字符串。

**StringBuffer** 和StringBuilder功能完全一样，区别在于所有方法都加了`synchronized`关键字，线程安全但性能稍差，适合**多线程**环境。

简单选择：优先用StringBuilder，需要线程安全时用StringBuffer，字符串基本不变时用String。实际开发中StringBuffer用得很少，因为字符串拼接操作通常发生在单个方法内部，不涉及多线程竞争。

---
### · 为什么String要设计成不可变？

**安全性**。String广泛用于敏感场景，比如文件路径、数据库连接URL、网络地址、类加载的类名等。如果String可变，传递给方法后被意外或恶意修改，会造成严重的安全隐患。不可变保证了传递出去的字符串不会被篡改。

**支持字符串常量池**。JVM维护一个字符串常量池来复用字符串对象，相同内容的字符串字面量指向同一个对象。这能显著节省内存，但前提是字符串不可变——如果一个引用能修改字符串内容，所有共享这个对象的引用都会受影响。

**hashCode缓存**。String的hashCode在首次计算后会被缓存，因为内容不会变，hashCode永远不变。这让String非常适合作为HashMap的key，查找效率高且安全。如果可变，放入HashMap后内容被修改，hashCode变了，这个键值对就再也找不到了。

附带的好处是**天然线程安全**，多线程环境下可以自由共享String对象而无需同步。

---
### · StringBuilder底层实现

`StringBuilder`继承自`AbstractStringBuilder`，核心是一个`char`数组加一个`count`变量记录实际字符数。

```java
abstract class AbstractStringBuilder {
    char[] value;  // JDK 9之后改为byte[]
    int count;     // 实际字符数量
}
```

`append`操作先检查容量是否足够，不够就扩容，然后把新内容拷贝到数组末尾并更新`count`。整个过程都是在原数组上操作，不创建新对象。

扩容策略是原容量乘2再加2。假设当前容量是16，扩容后就是34；如果仍不够，就直接扩到所需大小。扩容涉及创建新数组和拷贝旧数据，开销不小，所以创建`StringBuilder`时最好预估最终长度，通过构造器参数指定初始容量。

JDK 9把`String`、`StringBuilder`、`StringBuffer`底层的`char`数组全换成了`byte`数组，同时加了一个`coder`字段标记编码方式。

```java
// JDK 9+
public final class String {
    private final byte[] value;
    private final byte coder;  // 0=LATIN1, 1=UTF16
}
```

改动原因是大部分字符串实际上都是英文、数字这些Latin-1字符，一个字节就够了。以前用`char`数组，每个字符固定占2字节，纯英文字符串浪费一半内存。改成`byte`数组后，Latin-1字符串内存占用直接减半。
这个优化叫Compact Strings，对内存敏感或需要处理海量字符串的场景提升明显。

---
### · 编译器的字符串拼接优化

编译器会对字符串拼接进行优化，但优化程度取决于拼接内容。

**纯字面量拼接**，编译器直接在编译期合并成一个字符串常量：

```java
String s = "Hello" + " " + "World";
// 编译后等价于
String s = "Hello World";
```

**包含变量的拼接**，JDK 8及之前编译器会转换为StringBuilder链式调用：

```java
String s = "Hello" + name + "!";
// 编译后等价于
String s = new StringBuilder().append("Hello").append(name).append("!").toString();
```

**JDK 9之后**引入了invokedynamic指令来处理字符串拼接，运行时由JVM决定最优策略，性能更好且更灵活。

**但循环内拼接编译器优化不了**：

```java
String result = "";
for (int i = 0; i < 10000; i++) {
    result += i;  // 每次循环都创建新的StringBuilder和String对象
}
```

每次迭代都会创建`StringBuilder`、拼接、调用`toString`生成新`String`，效率很低。这种场景必须手动在循环外创建`StringBuilder`：

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append(i);
}
String result = sb.toString();
```

简单说，单行拼接交给编译器优化即可，循环拼接必须手动用StringBuilder。

---

### · StringBuilder扩容是原容量乘2再加2，为什么要加2？

加2主要是为了处理边界情况。

当容量为0时，乘2还是0，加2保证至少能扩到2。虽然默认构造器初始容量是16，但StringBuilder有个接受String参数的构造器，如果传入空字符串，初始容量就是0+16=16没问题；但如果直接调用内部方法或通过某些路径导致容量为0，纯乘2就卡住了。

另外加2还能为小字符串多留一点余量，减少频繁扩容的可能。比如容量1扩容后是4而不是2，容量2扩容后是6而不是4。

不过说实话，这个设计更多是历史惯例。JDK早期版本就这么定了，后续版本保持兼容没改。加2比加1稍微宽裕一点，比加更大的数又不会太浪费，算是个折中选择。

> [!quote] 参考
> [Java的StringBuilder是怎么实现的？](https://www.mianshiya.com/question/1780933294532096002)

---
### · StringBuffer 的 `synchronized` 加在哪了？

StringBuffer 的 `synchronized` 修饰符加在**所有公共方法**上（例如 `append()`、`insert()`、`delete()` 等）。  

具体来说，StringBuffer 的每个对外暴露的操作方法都通过 `synchronized` 关键字实现了线程安全，例如：  

```java
public synchronized StringBuffer append(String str) {
    // ...
}
```

这种设计保证了在多线程环境下，对 StringBuffer 对象的修改操作是原子的，避免了并发修改导致的数据不一致问题。

---
### · String 的 intern 方法是干什么的？什么场景下会用？

`String.intern()` 是一个将字符串放入**字符串常量池**并返回池中引用的方法。

```java
String s1 = new String("hello");  // 堆中创建新对象
String s2 = s1.intern();          // 返回常量池中的 "hello"
String s3 = "hello";              // 常量池中的 "hello"

System.out.println(s1 == s3);     // false，s1 在堆中
System.out.println(s2 == s3);     // true，都指向常量池
```

调用 `intern()` 时，JVM 会检查常量池中是否已有内容相同的字符串：有则返回池中引用，没有则将该字符串加入池中再返回。

**1. 大量重复字符串的内存优化**

比如解析日志或 CSV 文件时，某些字段值会反复出现：

```java
// 假设解析百万行数据，status 只有 "SUCCESS"、"FAILED" 等几种值
String status = parseStatus(line).intern();
```

这样所有相同状态共享一个对象，而不是创建百万个重复的 String 实例。

**2. 需要用 == 快速比较的场景**

`intern()` 后可以用 `==` 代替 `equals()`，性能更好：

```java
String key = inputKey.intern();
if (key == "EXPECTED_VALUE") { ... }
```

实际上**很少需要手动调用** `intern()`，原因是JDK 7+ 将字符串常量池移到了堆中，GC 可以回收。过度使用反而可能导致常量池膨胀、哈希冲突增加，编译期字面量和 `+` 拼接的常量已经自动 `intern`。

---

### · Java中包装类型和基本对象类型的区别是什么？

基本类型是直接存储值的简单数据，包括`byte`、`short`、`int`、`long`、`float`、`double`、`char`、`boolean`。包装类型是对应的对象形式，分别是`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean`。

**存储位置不同**。基本类型的局部变量存在**栈**上，作为字段时随对象存在堆中。包装类型是对象，实例在**堆**上，变量持有的是**引用**。

**默认值不同**。基本类型作为成员变量默认值是0、0.0或false。包装类型默认值是null，使用前必须判空，否则拆箱时会抛`NullPointerException`。

**能否用于泛型**。泛型只能使用包装类型，`List<int>`不合法，必须写`List<Integer>`。

**性能差异**。基本类型直接运算，包装类型涉及对象创建、内存分配、装箱拆箱开销，性能敏感场景优先用基本类型。

**相等性比较**。基本类型用`==`比较值本身，包装类型用`==`比较的是引用，比较值应该用`equals`。但`Integer`在-128到127范围内有缓存，`==`比较可能返回true，这容易踩坑：

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b);  // true，缓存范围内

Integer c = 128;
Integer d = 128;
System.out.println(c == d);  // false，超出缓存
```

选择原则：性能敏感、确定不为null时用基本类型；需要表示缺失值、用于集合泛型时用包装类型。

所有包装类都是不可变类，它们都声明为`final`防止继承，内部存储值的字段也是`final`的，没有提供任何修改方法。

```java
public final class Integer extends Number {
    private final int value;
    // 没有setValue方法
}
```

设计成不可变主要有三个原因。一是安全性，包装类经常作为`HashMap`的key或在多线程间传递，不可变保证了`hashCode`稳定和线程安全。二是支持缓存机制，`Integer`缓存-128到127的实例供复用，如果可变就会互相影响。三是与基本类型语义一致，`int a = 1`修改a实际上是重新赋值而不是修改原来的1，包装类型保持同样的行为。

所以对包装类型的任何"修改"操作实际上都是创建新对象：

```java
Integer a = 100;
a += 1;  // 实际上是 a = Integer.valueOf(a.intValue() + 1)
```

---

### · 为何要有包装类型？

因为Java泛型和集合框架只能操作对象，无法直接使用基本类型。`List<int>`是不合法的，必须写成`List<Integer>`。没有包装类型，基本类型就无法参与泛型、集合、反射这些面向对象的机制。

另外包装类型可以表示null，这在很多场景下很重要。比如数据库查询结果可能为空、HTTP参数可能缺失，用Integer可以区分"值是0"还是"没有值"，用int就无法表达这种语义。

包装类还提供了大量实用方法和常量，比如`Integer.parseInt()`、`Integer.MAX_VALUE`、`Double.isNaN()`等，这些如果没有包装类就没地方放。

---
### · 什么是自动装箱和拆箱？

自动装箱是把基本类型自动转成对应的包装类型（如 `int` → `Integer`），自动拆箱反过来（`Integer` → `int`）。这是 Java 5 引入的语法糖，编译器自动插入 `Integer.valueOf()` 和 `intValue()` 调用，让基本类型和包装类型可以混用。需要注意的是频繁装箱会产生大量对象影响性能，以及拆箱时如果包装类型为 null 会抛 `NullPointerException`。


> [!quote] 参考
> [什么是自动装箱和拆箱？](https://www.mianshiya.com/bank/1787463103423897602/question/1800393156791181313#heading-0)

---

### · 自动装箱拆箱的实现

自动装箱拆箱是编译器层面的语法糖，编译时会自动插入转换方法调用。

装箱时编译器插入`valueOf`方法：

```java
Integer a = 100;
// 编译后等价于
Integer a = Integer.valueOf(100);
```

拆箱时编译器插入`xxxValue`方法：

```java
int b = a;
// 编译后等价于
int b = a.intValue();
```

valueOf方法内部有缓存机制，Integer默认缓存-128到127：

```java
public static Integer valueOf(int i) {
    if (i >= -128 && i <= 127) {
        return IntegerCache.cache[i + 128];
    }
    return new Integer(i);
}
```

这就解释了为什么范围内的`Integer`用`==`比较返回true，超出范围返回false——缓存范围内返回的是同一个对象。

需要注意的坑：包装类型为null时拆箱会抛NPE。

```java
Integer a = null;
int b = a;  // NullPointerException，因为实际调用的是a.intValue()
```

---

### · 包装类缓存机制详解

Integer缓存默认范围是-128到127，这个范围覆盖了日常使用最频繁的小整数。JVM启动时就创建好这些对象放在IntegerCache数组中，valueOf方法直接返回缓存对象，避免重复创建。

```java
private static class IntegerCache {
    static final int low = -128;
    static final int high;  // 默认127，可配置
    static final Integer[] cache;
    
    static {
        int h = 127;
        // 可通过JVM参数调整上限
        String value = VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (value != null) {
            h = Math.max(Integer.parseInt(value), 127);
        }
        high = h;
        cache = new Integer[(high - low) + 1];
        for (int i = 0; i < cache.length; i++) {
            cache[i] = new Integer(low + i);
        }
    }
}
```

可以通过JVM参数`-XX:AutoBoxCacheMax=1000`调大上限，适合业务中大量使用某个范围整数的场景。下限-128是固定的，不能调整。

其他包装类型也有缓存，但范围固定不可配置：Byte、Short、Long缓存-128到127，Character缓存0到127，Boolean缓存TRUE和FALSE两个实例。Float和Double没有缓存，因为浮点数范围内的值太多，缓存意义不大。

---
### · 基本类型和包装类型都各占几个字节？

|类型|字节数|位数|范围|
|---|---|---|---|
|byte|1|8|-128 ~ 127|
|short|2|16|-32768 ~ 32767|
|int|4|32|约±21亿|
|long|8|64|约±922亿亿|
|float|4|32|约±3.4×10³⁸|
|double|8|64|约±1.8×10³⁰⁸|
|char|2|16|0 ~ 65535|
|boolean|1*|-|true/false|

boolean比较特殊，JVM规范没有严格规定大小。单个boolean通常当作int处理占4字节，boolean数组中每个元素占1字节。

包装类型作为对象，除了存储值本身还有对象头开销。以64位JVM开启压缩指针（默认开启）为例：

|类型|对象头|数据|对齐填充|总计|
|---|---|---|---|---|
|Byte|12|1|3|16|
|Short|12|2|2|16|
|Integer|12|4|0|16|
|Long|12|8|4|24|
|Float|12|4|0|16|
|Double|12|8|4|24|
|Character|12|2|2|16|
|Boolean|12|1|3|16|

对象头12字节包含Mark Word（8字节）和类型指针（压缩后4字节）。对象大小必须是8的倍数，不足的部分用对齐填充补齐。

对比一下：int占4字节，Integer占16字节，是4倍。long占8字节，Long占24字节，是3倍。这就是为什么性能敏感场景要优先用基本类型。


> [!quote] 参考
> [Java的基本数据类型有哪些？](https://www.mianshiya.com/bank/1787463103423897602/question/1800392994257707009#heading-0)

---
### · Integer的缓存池是在什么时候初始化的？会不会有并发问题？

`IntegerCache` 是 `Integer` 的静态内部类，在类加载阶段就初始化好了。JVM 保证类加载是线程安全的，所以不存在并发问题。缓存数组一旦初始化完成就不会再变，所有线程共享读取，不需要加锁。

超出缓存范围时，`Integer.valueOf(a)`每次都直接new一个新对象，不会放入缓存池。

```java
public static Integer valueOf(int i) {
    if (i >= -128 && i <= 127) {
        return IntegerCache.cache[i + 128];  // 缓存范围内，返回缓存对象
    }
    return new Integer(i);  // 超出范围，每次new新对象
}
```

所以这个代码：

```java
Integer a = 129;  // new Integer(129)
Integer b = 129;  // new Integer(129)，另一个新对象
System.out.println(a == b);  // false，两个不同的对象
```

缓存池是固定大小的数组，在JVM启动时就初始化好了，运行时不会动态扩展。如果需要扩大缓存范围，只能通过JVM参数`-XX:AutoBoxCacheMax=256`在启动前配置。

---
### · 为什么说在循环里面频繁拆装箱性能很差？差到什么程度？

循环中频繁装箱拆箱性能差是因为每次装箱都可能创建新对象。虽然`Integer`有-128到127的缓存，但超出这个范围每次`Integer.valueOf()`都会`new`一个新`Integer`对象。

以图中代码为例，循环1000万次，每次`sum += i`实际上是：

```java
sum = Integer.valueOf(sum.intValue() + i);
```

如果`sum`的值超过127（几乎立刻就会超过），每次循环都要在堆上创建一个新`Integer`对象，然后旧对象变成垃圾等待GC回收。1000万次循环就是近1000万个临时对象，带来的开销包括：内存分配、对象初始化、GC压力。

性能差距大概在**3到5倍**左右，具体取决于JVM版本和GC策略。数据量越大、GC触发越频繁，差距越明显。

解决方案很简单，循环内部用基本类型：

```java
long sum = 0L;  // 用基本类型
for (int i = 0; i < 1000000; i++) {
    sum += i;
}
```

---
### · Integer 和 int 在方法参数上有什么区别？传参的时候会发生什么？

`int`作为参数是值传递，方法内修改不影响外部。`Integer`作为参数传递的是引用的副本，但由于`Integer`不可变，方法内任何"修改"都是创建新对象并让局部引用指向它，同样不影响外部。

---
### · Long的缓存范围能像Integer一样调整吗？

不能。Long的缓存范围固定是-128到127，没有提供JVM参数来调整。

```java
private static class LongCache {
    static final Long[] cache = new Long[256];
    
    static {
        for (int i = 0; i < 256; i++) {
            cache[i] = new Long(i - 128);
        }
    }
}
```

只有Integer提供了`-XX:AutoBoxCacheMax`参数可以调整上限，其他包装类型的缓存范围都是写死的：Byte、Short、Long固定-128到127，Character固定0到127，Boolean只缓存TRUE和FALSE两个实例，Float和Double没有缓存。

为什么只有Integer可配置？可能是因为int是最常用的整数类型，实际业务中经常出现超过127但重复率很高的场景，比如状态码、年龄、数量等。而long通常用于id、时间戳这种值域很大且不重复的场景，扩大缓存意义不大。

---

### · 接口和抽象类有什么区别

接口和抽象类在设计动机上有所不同。

接口的设计是**自上而下**的。我们知晓某一行为，于是基于这些行为约束定义了接口，需要这些行为的类来实现它。

抽象类的设计是**自下而上**的。我们写了很多类，发现它们之间有共性，很多代码可以复用，于是将公共逻辑封装成抽象类，减少冗余。

所谓自上而下是先约定接口再实现，自下而上是先有具体类再抽象出父类。可能和学校教的不太一样，但实战中很多抽象类都是重构的产物。

其他区别：

**方法实现**：接口中的方法默认是`public abstract`，Java 8之后可以有`default`方法和`static`方法。抽象类可以包含`abstract`方法和具体方法，允许子类继承并复用。

**构造函数和成员变量**：接口不能有构造函数，成员变量默认是`public static final`常量。抽象类可以有构造函数，成员变量可以有不同访问修饰符且不必是常量。

**多继承**：抽象类只能单继承，接口可以多实现。

---
### · 抽象类能不能有构造函数？有何作用？

可以有。抽象类的构造函数用于初始化抽象类中定义的字段，供子类构造时调用。

虽然抽象类不能直接实例化，但子类实例化时必须先调用父类构造器完成父类部分的初始化。如果抽象类没有无参构造器，子类构造器必须显式调用`super(...)`。

这也体现了抽象类和接口的区别之一：抽象类可以持有状态并通过构造器初始化，接口不能。

---
### · 接口里的变量为何默认是`public static final`？

因为接口的定位是定义行为契约，不是持有状态。

**`public`**：接口是公开的契约，所有实现类和使用方都需要访问，私有变量没有意义。

**`static`**：接口不能实例化，没有实例就不可能有实例变量，只能是类级别的静态变量。

**`final`**：如果变量可变，不同实现类可能修改它导致混乱。既然接口定义的是契约，契约中的常量就应该是不可变的。

---
### · 一个类可以同时继承抽象类和实现接口吗？

可以。Java 允许一个类继承一个抽象类的同时实现多个接口。这也是 Java 解决单继承限制的常用手段，核心代码复用放抽象类里，额外的能力通过接口来补充。

Java集合框架中很多类都是这样设计的，比如ArrayList继承AbstractList抽象类，同时实现List、RandomAccess、Serializable等接口。

---

### · Java 中 `hashCode` 和 `equals` 方法是什么？它们与 == 操作符有什么区别？

**`==`操作符**比较的是内存地址，判断两个引用是否指向同一个对象。

```java
String a = new String("hello");
String b = new String("hello");
System.out.println(a == b);  // false，不是同一个对象
```

**equals方法**默认行为和`==`一样，但设计意图是让子类重写来定义"逻辑相等"。`String`重写了`equals`来比较内容：

```java
System.out.println(a.equals(b));  // true，内容相同
```

**`hashCode方法`** 返回对象的哈希码，用于`HashMap`、`HashSet`等哈希结构快速定位。默认实现基于内存地址生成，重写`equals`时必须同时重写`hashCode`。

三者的关系：

- `a == b`为true，则`a.equals(b)`必为true，`hashCode`必相同
- `a.equals(b)`为true，`hashCode`必须相同（约定）
- `hashCode`相同，`equals`不一定为true（哈希冲突）

为什么重写`equals`必须重写`hashCode`？`HashMap`先用`hashCode`定位桶，再用`equals`确认。如果两个对象`equals`为true但`hashCode`不同，HashMap会认为它们在不同的桶里，导致逻辑错误：

```java
class User {
    String name;
    
    @Override
    public boolean equals(Object o) {
        return name.equals(((User) o).name);
    }
    
    // 没重写hashCode
}

User u1 = new User("张三");
User u2 = new User("张三");

Set<User> set = new HashSet<>();
set.add(u1);
set.contains(u2);  // 可能返回false，因为hashCode不同落在不同桶
```

---
### · 重写 equals 的五大原则

重写equals必须满足五个原则：

**自反性**：对象必须等于自身，`x.equals(x)`永远返回true。

**对称性**：如果`x.equals(y)`为true，那么`y.equals(x)`也必须为true。

**传递性**：如果`x.equals(y)`为true且`y.equals(z)`为true，那么`x.equals(z)`也必须为true。

**一致性**：只要对象状态不变，多次调用`x.equals(y)`的结果必须一致。

**非空性**：任何非null对象`x.equals(null)`必须返回false。

标准写法：

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;                          // 自反性+性能优化
    if (o == null || getClass() != o.getClass()) return false;  // 非空性+类型检查
    User user = (User) o;
    return age == user.age && Objects.equals(name, user.name);  // 字段比较
}
```

常见错误是对称性问题，比如父类和子类互相equals时行为不一致。用`getClass()`而非`instanceof`可以避免这个问题，但也牺牲了多态性。具体选择取决于业务需求。

---

### · hashCode 的默认实现

Object的`hashCode`是`native`方法，OpenJDK 8默认使用Xorshift随机数算法，首次调用时生成随机值并缓存到对象头的Mark Word中。

> 注意：默认实现跟内存地址没有必然联系，虽然很多文章这么说，但HotSpot实际有6种hashCode生成策略，可通过`-XX:hashCode`参数切换。

---

### · String 重写 hashCode 是怎么实现的？

String的`hashCode`基于内容计算，使用经典的31系数多项式哈希：

```java
public int hashCode() {
    int h = hash;  // 缓存值，默认0
    if (h == 0 && value.length > 0) {
        char[] val = value;
        for (int i = 0; i < val.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;  // 缓存结果
    }
    return h;
}
```

计算公式是：`s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]`

比如"abc"的`hashCode`：`'a'*31² + 'b'*31 + 'c'` = `97*961 + 98*31 + 99` = `96354`

**为什么选31？**

一是31是奇素数，乘以素数能让哈希值分布更均匀，减少冲突。二是31乘法可以被JVM优化为位运算：`31 * h` 等价于 `(h << 5) - h`，性能更好。三是31不太大也不太小，计算结果不容易溢出且离散性好。

**缓存机制**：String不可变，hashCode首次计算后缓存在hash字段中，后续调用直接返回，不重复计算。

---
### · 怎么正确重写hashCode？

基本原则是`equals`中用到的字段都要参与`hashCode`计算，保证`equals`相等的对象`hashCode`一定相同。

**标准写法**，使用`Objects.hash()`：

```java
@Override
public int hashCode() {
    return Objects.hash(name, age, email);
}
```

简单方便，内部使用31系数计算，适合大多数场景。

**手动实现**，性能更好：

```java
@Override
public int hashCode() {
    int result = 17;  // 非零初始值
    result = 31 * result + (name == null ? 0 : name.hashCode());
    result = 31 * result + age;
    result = 31 * result + (email == null ? 0 : email.hashCode());
    return result;
}
```

实际开发中直接用IDE生成或Lombok的`@EqualsAndHashCode`注解最省事。

---

### · HashMap 的 key 用可变对象有什么风险？

可变对象作为key，如果修改了参与`hashCode`计算的字段，会导致这个键值对"丢失"。

```java
class User {
    String name;
    
    public User(String name) {
        this.name = name;
    }
    
    @Override
    public int hashCode() {
        return name.hashCode();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        return name.equals(((User) o).name);
    }
}

Map<User, String> map = new HashMap<>();
User user = new User("张三");
map.put(user, "数据");

System.out.println(map.get(user));  // "数据"

user.name = "李四";  // 修改了key

System.out.println(map.get(user));  // null，找不到了
```

原因是`put`时按"张三"的`hashCode`放到某个桶里，修改后`get`时按"李四"的`hashCode`去另一个桶找，自然找不到。更糟的是这个键值对还占着内存，却无法访问也无法删除，造成内存泄漏。

所以`HashMap`的`key`应该用不可变对象，比如`String`、`Integer`、或者自定义的不可变类。如果必须用可变对象，至少保证放入`Map`后不再修改参与`hashCode`计算的字段。

---
### · 什么是Java中的动态代理？

动态代理是在运行时动态生成代理类，无需手动编写代理代码。它可以在不修改原有类的情况下增强方法行为，是AOP的核心实现机制。

Java提供两种动态代理方式：

**JDK动态代理**，基于接口。通过`Proxy.newProxyInstance()`创建代理对象，核心是实现`InvocationHandler`接口，在invoke方法中编写增强逻辑并调用目标方法。

```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    System.out.println("方法执行前");
    Object result = method.invoke(target, args);
    System.out.println("方法执行后");
    return result;
}
```

**CGLIB动态代理**，基于继承。通过`Enhancer`生成目标类的子类，实现`MethodInterceptor`接口进行方法拦截。可以代理没有接口的类，但不能代理`final`类和`final`方法。

**两者对比**：

|     | JDK动态代理  | CGLIB         |
| --- | -------- | ------------- |
| 要求  | 必须有接口    | 不需要接口         |
| 原理  | 实现接口     | 继承目标类         |
| 限制  | 只能代理接口方法 | 不能代理final类和方法 |

**Spring AOP默认策略**：有接口用JDK代理，没接口用CGLIB。

---

### · JDK动态代理的底层实现原理

JDK动态代理在运行时动态生成一个实现目标接口的代理类。

调用`Proxy.newProxyInstance()`时，JVM会做以下几件事：

1. 根据传入的接口数组动态生成代理类的字节码
2. 通过`ClassLoader`加载这个类
3. 实例化代理对象并关联`InvocationHandler`

生成的代理类大致结构如下：

```java
public final class $Proxy0 extends Proxy implements UserService {
    private static Method m3;  // save方法的Method对象
    
    static {
        m3 = Class.forName("UserService").getMethod("save");
    }
    
    public $Proxy0(InvocationHandler h) {
        super(h);
    }
    
    @Override
    public void save() {
        // 所有调用都转发给InvocationHandler
        h.invoke(this, m3, null);
    }
}
```

关键点：

**继承Proxy类**：所以只能代理接口，因为Java单继承限制。

**静态缓存Method对象**：避免每次调用都反射获取，提升性能。

**所有方法转发给`InvocationHandler`**：代理类本身不包含业务逻辑，只是个转发器。

可以通过`System.setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true")`把生成的代理类字节码保存到磁盘查看。

---

### · CGLIB代理的底层实现原理

CGLIB通过ASM字节码框架在运行时生成目标类的子类来实现代理。

调用`Enhancer.create()`时，CGLIB会做以下几件事：

1. 用ASM生成目标类的子类字节码
2. 重写所有非final方法，插入拦截逻辑
3. 通过ClassLoader加载并实例化代理对象

生成的代理类大致结构如下：

```java
public class UserService$$EnhancerByCGLIB extends UserService {
    private MethodInterceptor interceptor;
    private static Method saveMethod;
    private static MethodProxy saveMethodProxy;
    
    static {
        saveMethod = Class.forName("UserService").getMethod("save");
        saveMethodProxy = MethodProxy.create(...);
    }
    
    @Override
    public void save() {
        interceptor.intercept(this, saveMethod, null, saveMethodProxy);
    }
}
```

关键点：

**继承目标类**：所以不能代理final类，也不能代理final方法。

**MethodProxy机制**：CGLIB为每个方法生成一个MethodProxy，调用`invokeSuper()`时不走反射，而是直接调用父类方法，比JDK代理的`method.invoke()`更快。

**FastClass机制**：CGLIB为目标类和代理类各生成一个FastClass，通过方法索引直接定位方法调用，避免反射开销。

所以CGLIB生成代理类较慢（要生成多个类），但方法调用比JDK动态代理快。不过JDK 8之后差距已经不大。

---

### · Spring 为什么从 JDK 代理切换到默认用 CGLIB？

Spring Boot 2.0之后默认使用CGLIB，主要原因是避免类型转换问题。

JDK代理生成的对象只能转型为接口类型，不能转型为实现类：

```java
@Service
public class UserServiceImpl implements UserService {
    // ...
}

// JDK代理时
@Autowired
private UserServiceImpl userService;  // 报错！代理对象无法转型为实现类

@Autowired
private UserService userService;  // 只能用接口接收
```

CGLIB代理生成的是目标类的子类，可以转型为实现类或接口：

```java
// CGLIB代理时
@Autowired
private UserServiceImpl userService;  // 正常工作

@Autowired
private UserService userService;  // 也正常
```

实际开发中很多人习惯用实现类注入而不是接口，JDK代理会导致启动失败。切换为CGLIB默认后减少了这类困惑。

可以通过配置切回JDK代理：

```properties
spring.aop.proxy-target-class=false
```

---
### · 代理对象里面调用 this.xxx() 切面不生效，怎么解决？

因为this指向的是目标对象本身，不是代理对象，调用直接走了原方法，绕过了代理。

```java
@Service
public class UserService {
    
    @Transactional
    public void methodA() {
        this.methodB();  // 切面不生效，this是原对象
    }
    
    @Transactional
    public void methodB() {
        // ...
    }
}
```

**解决方案一：注入自己**

```java
@Service
public class UserService {
    @Autowired
    private UserService self;  // 注入的是代理对象
    
    public void methodA() {
        self.methodB();  // 走代理，切面生效
    }
}
```

**解决方案二：从ApplicationContext获取**

```java
@Service
public class UserService {
    @Autowired
    private ApplicationContext context;
    
    public void methodA() {
        context.getBean(UserService.class).methodB();
    }
}
```

**解决方案三：AopContext获取当前代理**

```java
// 需要开启exposeProxy
@EnableAspectJAutoProxy(exposeProxy = true)

public void methodA() {
    ((UserService) AopContext.currentProxy()).methodB();
}
```

---
### · CGLIB为什么不能代理`final`方法？

因为CGLIB通过继承实现代理，而final修饰的类、方法、字段在Java语义上不允许被继承或重写。

**`final`类不能代理**：CGLIB需要生成目标类的子类，`final`类不能被继承，所以无法代理。

**`final`方法不能代理**：CGLIB通过重写方法插入拦截逻辑，`final`方法不能被重写，子类中无法拦截。

```java
public class UserService {
    public final void save() {  // CGLIB无法拦截
        // ...
    }
    
    public void update() {  // 可以正常代理
        // ...
    }
}
```

调用代理对象的`final`方法时，直接执行父类原方法，切面不生效。

**private方法同理**：子类无法重写父类的`private`方法，所以也不能代理。

这是Java语言层面的限制，不是CGLIB的缺陷。JDK动态代理基于接口，接口方法默认是`public`非`final`的，不存在这个问题。

---
### · JDK动态代理和CGLIB动态代理有什么区别？

**实现原理不同**：JDK动态代理基于接口，运行时生成实现目标接口的代理类。CGLIB基于继承，通过ASM字节码框架生成目标类的子类。

**使用限制不同**：JDK代理要求目标类必须实现接口，只能代理接口中定义的方法。CGLIB不需要接口，但不能代理final类和final方法，因为无法继承和重写。

**代理对象类型不同**：JDK代理生成的对象只能转型为接口类型，不能转型为实现类。CGLIB生成的是子类，可以转型为目标类或其接口。

**性能差异**：生成代理类时JDK更快，CGLIB需要生成多个辅助类。方法调用上早期CGLIB更快（FastClass机制避免反射），JDK 8之后差距已经很小。

**Spring中的选择**：Spring Boot 2.0之前有接口用JDK代理，没接口用CGLIB。2.0之后默认都用CGLIB，主要是避免类型转换问题，让开发者可以用实现类注入。

> [!quote] 参考
> [JDK动态代理和CGLIB动态代理有什么区别？](https://www.mianshiya.com/bank/1787463103423897602/question/1780933294599204866#heading-0)

---
### · Java中注解是什么？

注解本质上就是个**标记**，是一种给代码添加元数据的机制。你可以把注解打在类上、方法上、字段上、参数上，标记里还能带一些属性值。

注解本身不会改变程序的运行逻辑，但编译器、框架、工具可以读取这些标记来做特定处理，比如编译时检查、生成代码、运行时做依赖注入。

注解处理的三个阶段：

1. **源码阶段**：注解只存在于`.java`文件中，编译时被编译器读取处理，编译完就丢弃。典型例子是`@Override`，编译器检查方法签名是否正确，检查完使命就完成了。
   
2. **字节码阶段**：注解会写进`.class`文件，但JVM加载类时不会把注解信息加载到内存。用于字节码工具做静态分析。
   
3. **运行时阶段**：注解信息会被加载到JVM内存，程序可以通过反射API读取。Spring的`@Autowired`、`@Transactional`都是这种。

---

### · 元注解

元注解是用于定义注解的注解，Java提供了四个核心元注解。

**@Target**：指定注解可以用在哪里。

```java
@Target(ElementType.METHOD)  // 只能用在方法上
@Target({ElementType.TYPE, ElementType.METHOD})  // 可用在类和方法上
```

常用值：TYPE（类/接口）、METHOD（方法）、FIELD（字段）、PARAMETER（参数）、CONSTRUCTOR（构造器）。

**@Retention**：指定注解保留到什么阶段。

```java
@Retention(RetentionPolicy.SOURCE)   // 只保留在源码，编译后丢弃
@Retention(RetentionPolicy.CLASS)    // 保留到字节码，运行时不可读（默认）
@Retention(RetentionPolicy.RUNTIME)  // 运行时可通过反射读取
```

**@Documented**：注解会出现在javadoc文档中。

**@Inherited**：子类自动继承父类的该注解（仅对类注解有效）。

```java
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnnotation {}

@MyAnnotation
class Parent {}

class Child extends Parent {}  // Child也带有@MyAnnotation
```

自定义运行时注解的标准写法：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
    String value() default "";
}
```

---

### · 注解的底层实现

注解本质上是一个继承了`java.lang.annotation.Annotation`接口的特殊接口。

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
    String value() default "";
}
```

编译后实际生成：

```java
public interface Log extends Annotation {
    String value();
}
```

运行时通过反射获取注解时，JVM会动态生成一个代理类来实现这个接口。代理类内部用Map存储注解的属性值，调用属性方法时从Map中取值返回。

```java
// 反射获取注解
Method method = MyClass.class.getMethod("doSomething");
Log log = method.getAnnotation(Log.class);
String value = log.value();  // 实际调用的是代理对象的方法
```

---

### · 注解处理器APT

APT（Annotation Processing Tool）是在编译期处理注解的机制，可以在编译时扫描注解并生成新的源代码或文件。

**工作时机**：javac编译时，在源码转字节码之前执行。生成的代码会和原代码一起编译。

**典型应用**：

- Lombok：`@Data`生成getter/setter/toString
- MapStruct：生成对象映射代码
- Dagger：生成依赖注入代码
- ButterKnife：生成View绑定代码

> [!quote] 参考
> [Java中注解是什么？](https://www.mianshiya.com/bank/1787463103423897602/question/1780933294607593473#heading-9)

---
### · Java 反射机制

反射机制就是让程序在运行时能够"照镜子"看自己，动态获取类的结构信息，包括方法、字段、构造函数，还能直接操作它们。编译期不需要知道具体类型，运行时再决定要用哪个类、调哪个方法。

反射的核心流程：

1. 获取Class对象：通过类名字符串、.class语法或对象实例获取
2. 获取成员信息：从Class对象中获取Field、Method、Constructor
3. 操作目标对象：创建实例、读写字段、调用方法

反射的三种获取Class对象的方式：

```java
// 1. 通过全限定类名，框架常用这种
Class<?> clazz = Class.forName("com.example.MyClass");

// 2. 通过类字面量，编译期就能确定
Class<?> clazz = MyClass.class;

// 3. 通过对象实例获取
Class<?> clazz = obj.getClass();
```

拿到Class对象后就可以搞事情了：

```java
// 创建实例，newInstance()在JDK9已标记过时
Constructor<?> constructor = clazz.getConstructor();
Object obj = constructor.newInstance();

// 访问私有字段
Field field = clazz.getDeclaredField("secretField");
field.setAccessible(true);  // 暴力破解访问权限
Object value = field.get(obj);

// 调用方法
Method method = clazz.getMethod("doSomething", String.class);
Object result = method.invoke(obj, "参数");
```

反射广泛用于框架开发，Spring的依赖注入、MyBatis的结果映射、JUnit的测试执行都依赖反射。代价是性能比直接调用慢，因为要做类型检查、访问权限验证，而且无法被JIT优化。高频调用场景应该缓存Method/Field对象，避免重复获取。

---

### · 反射为什么慢？

**类型检查和安全验证**：每次反射调用都要检查方法是否存在、参数类型是否匹配、调用者是否有访问权限。直接调用在编译期就完成了这些检查。

**无法JIT优化**：普通方法调用可以被JIT编译器内联、优化。反射调用是动态的，JIT无法确定实际调用的是哪个方法，难以优化。

**参数的装箱拆箱**：`method.invoke(obj, args)`的参数是Object数组，基本类型必须装箱，返回值也要拆箱，产生额外开销。

---

### · 反射性能优化的手段

**缓存反射对象**：`getMethod()`、`getField()`每次调用都要遍历查找，开销大。把Method、Field、Constructor缓存起来复用。

```java
// 只获取一次，重复使用
private static final Method method = MyClass.class.getMethod("doSomething");
```

**关闭访问检查**：`setAccessible(true)`跳过每次调用时的权限验证，能提升性能。

```java
method.setAccessible(true);
field.setAccessible(true);
```

**使用MethodHandle**：JDK 7引入的方法句柄，比反射更接近直接调用，可以被JIT优化。

```java
MethodHandles.Lookup lookup = MethodHandles.lookup();
MethodHandle handle = lookup.findVirtual(MyClass.class, "doSomething", MethodType.methodType(void.class));
handle.invoke(obj);
```

**使用字节码生成**：CGLIB、ASM等工具直接生成字节码调用，绕过反射。Spring、MyBatis等框架广泛使用这种方式。

**批量操作时考虑代码生成**：如果是大量重复的反射操作，可以在启动时生成辅助类，运行时直接调用生成的代码。

优先级：缓存反射对象 > setAccessible > MethodHandle > 字节码生成。大多数场景做好缓存就够了。

---

### · Spring 用反射创建Bean不会有性能问题吗？

Spring用反射创建Bean不会有性能问题，因为Bean创建只发生在启动阶段。单例Bean在容器启动时创建一次，之后直接从缓存获取，运行期不会重复反射。而且Spring会缓存Constructor、Method、Field等反射对象，避免重复查找。依赖注入完成后，Bean之间的调用是直接方法调用，AOP也是通过代理对象直接调用或字节码增强，运行期几乎没有反射开销。启动时多花几秒完全可以接受，换来的是运行期的灵活性和高性能。真正需要担心反射性能的是业务代码中高频循环里使用反射的场景。

---
### · 为什么`newinstance()`方法被标记过时了？

`Class.newInstance()`被标记过时主要因为它有两个设计缺陷。

**异常处理不合理**：它会把构造器抛出的受检异常直接透传，破坏了Java的异常检查机制。调用者无法通过编译器知道可能抛出什么异常。

```java
// 构造器抛出IOException，但newInstance()没有声明
class MyClass {
    public MyClass() throws IOException {
        throw new IOException();
    }
}

MyClass.class.newInstance();  // IOException被偷偷抛出，编译器不强制捕获
```

**只能调用无参构造器**：如果类没有无参构造器，或者无参构造器是私有的，直接抛异常。

推荐使用`Constructor.newInstance()`替代：

```java
// 旧方式（过时）
Object obj = MyClass.class.newInstance();

// 新方式
Constructor<MyClass> constructor = MyClass.class.getConstructor();
Object obj = constructor.newInstance();
```

Constructor方式会把异常包装成`InvocationTargetException`，异常处理更规范，而且可以调用任意构造器，包括有参和私有的。

---

### · 什么是Java的SPI？

SPI（Service Provider Interface）是Java提供的服务发现机制，允许第三方为接口提供实现，运行时动态加载。

**核心思想**：框架定义接口，第三方提供实现，通过配置文件声明实现类，框架运行时自动发现并加载。

**标准用法**：

1. 定义接口：

```java
public interface PayService {
    void pay();
}
```

2. 提供实现：

```java
public class AlipayService implements PayService {
    public void pay() { System.out.println("支付宝支付"); }
}
```

3. 在`META-INF/services/`目录下创建以接口全限定名命名的文件：

```
# 文件名：com.example.PayService
# 内容：实现类全限定名
com.example.AlipayService
com.example.WechatPayService
```

4. 使用ServiceLoader加载：

```java
ServiceLoader<PayService> loader = ServiceLoader.load(PayService.class);
for (PayService service : loader) {
    service.pay();
}
```

**典型应用**：

- JDBC：`java.sql.Driver`，数据库厂商提供实现
- SLF4J：日志门面，加载具体日志实现
- Dubbo：扩展点机制基于SPI改进

**优点**：解耦接口与实现，扩展不用改代码，符合开闭原则。

**缺点**：一次性加载所有实现类，不能按需加载；没有依赖注入能力。Dubbo、Spring对SPI做了增强来解决这些问题。

---

### · ServiceLoader底层实现

ServiceLoader的核心逻辑是读取配置文件，通过反射实例化实现类。

**加载流程**：

1. 调用`ServiceLoader.load(PayService.class)`
2. 获取当前线程的ClassLoader
3. 拼接路径`META-INF/services/com.example.PayService`
4. 通过ClassLoader.getResources()读取所有jar包中的该文件
5. 解析文件内容，获取实现类的全限定名
6. 迭代时通过`Class.forName()`加载类，`newInstance()`创建实例

**简化的核心代码**：

```java
public final class ServiceLoader<S> implements Iterable<S> {
    private static final String PREFIX = "META-INF/services/";
    private final Class<S> service;
    private final ClassLoader loader;
    
    public static <S> ServiceLoader<S> load(Class<S> service) {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return new ServiceLoader<>(service, cl);
    }
    
    private class LazyIterator implements Iterator<S> {
        public S next() {
            // 读取配置文件获取类名
            String className = nextClassName();
            // 反射加载并实例化
            Class<?> clazz = Class.forName(className, false, loader);
            return service.cast(clazz.newInstance());
        }
    }
}
```

**关键点**：

- **懒加载**：迭代时才真正加载类和创建实例，不是一次性全部加载
- **使用线程上下文ClassLoader**：解决SPI在父ClassLoader定义接口、子ClassLoader提供实现的加载问题
- **缓存机制**：已加载的实例会缓存，重复迭代不会重新创建

> [!quote] 参考
> [什么是Java的SPI？](https://www.mianshiya.com/bank/1787463103423897602/question/1780933294620176386#heading-0)

---

### · Java 泛型的作用是什么?

泛型的核心作用是**类型安全**和**代码复用**。

**类型安全**：编译期检查类型，避免运行时`ClassCastException`。

```java
// 没有泛型，编译器不知道List里装的是什么
List list = new ArrayList();
list.add("hello");
list.add(123);  // 能放进去
String s = (String) list.get(1);  // 运行时才爆ClassCastException

// 有泛型，编译器直接拦截
List<String> list = new ArrayList<>();
list.add("hello");
list.add(123);  // 编译错误
String s = list.get(0);  // 不需要强转
```

**消除强制转换**：编译器自动插入类型转换，代码更简洁。

**代码复用**：一套代码处理多种类型，不用为每种类型写重复逻辑。

```java
// 不用为Integer、String、User各写一个List
List<Integer> intList = new ArrayList<>();
List<String> strList = new ArrayList<>();
List<User> userList = new ArrayList<>();
```

简单说，泛型把类型检查从运行期提前到编译期，既安全又灵活。

---

### · 泛型擦除是什么？

泛型擦除是指Java的泛型信息只存在于编译期，编译后会被擦除，运行时JVM看不到泛型类型。

```java
List<String> strList = new ArrayList<>();
List<Integer> intList = new ArrayList<>();

// 运行时是同一个类型
System.out.println(strList.getClass() == intList.getClass());  // true
```

**擦除规则**：

- 无界泛型`<T>`擦除为Object
	
- 有界泛型`<T extends Number>`擦除为Number
	
- 编译器在必要处插入强制类型转换

```java
// 编译前
public class Box<T> {
    private T value;
    public T get() { return value; }
}

// 擦除后
public class Box {
    private Object value;
    public Object get() { return value; }
}

// 使用处编译器插入强转
Box<String> box = new Box<>();
String s = box.get();  // 实际是 (String) box.get()
```

**为什么要擦除**：为了兼容Java 5之前的代码，让没有泛型的老代码和有泛型的新代码能共存。

**擦除带来的限制**：

- 不能`new T()`或`new T[]`
	
- 不能用基本类型作泛型参数，必须用包装类
	
- 运行时无法获取泛型实际类型
	
- `instanceof List<String>`不合法

---

### · 类型擦除后为什么反射还能拿到泛型的类型

因为泛型擦除不是完全擦除，类、字段、方法签名上的泛型信息会保留在字节码的Signature属性中。

擦除的是运行时对象的类型信息，保留的是类定义层面的元数据。

```java
class UserService {
    private List<String> names;
    
    public Map<String, Integer> getScores() { return null; }
}

// 反射可以获取字段的泛型类型
Field field = UserService.class.getDeclaredField("names");
Type type = field.getGenericType();  // List<String>

// 反射可以获取方法返回值的泛型类型
Method method = UserService.class.getMethod("getScores");
Type returnType = method.getGenericReturnType();  // Map<String, Integer>
```

**能获取的**：类声明、字段声明、方法参数和返回值上的泛型信息。

**不能获取的**：运行时创建的对象的泛型信息。

```java
List<String> list = new ArrayList<>();
list.getClass().getTypeParameters();  // 只能拿到T，拿不到String
```

这就是为什么很多框架要求通过子类或匿名类来传递泛型信息：

```java
// TypeReference模式，保留泛型信息
new TypeReference<List<String>>() {}
```

通过继承，泛型参数变成了类声明的一部分，被保留在字节码中，反射就能读取到。

---

### · 泛型类型的静态成员共享

由于类型擦除，不同泛型参数的同一个泛型类共享静态成员。

```java
class Box<T> {
    static int count = 0;
    
    public Box() {
        count++;
    }
}

Box<String> a = new Box<>();
Box<Integer> b = new Box<>();
Box<Double> c = new Box<>();

System.out.println(Box.count);  // 3
```

`Box<String>`、`Box<Integer>`、`Box<Double>`在运行时都是同一个`Box`类，静态成员只有一份。

**因此静态成员不能使用类的泛型参数**：

```java
class Box<T> {
    static T value;           // 编译错误
    static T getValue() {}    // 编译错误
    static void set(T t) {}   // 编译错误
}
```

原因很简单：静态成员属于类，不属于实例。如果允许`static T value`，那`Box<String>.value`和`Box<Integer>.value`是同一个变量还是不同变量？类型擦除后只有一个`Box`类，无法区分。

**静态方法可以有自己的泛型参数**：

```java
class Box<T> {
    // 这是方法自己的泛型参数E，不是类的T
    public static <E> E process(E input) {
        return input;
    }
}
```

> [!quote] 参考
> [类型擦除后为什么反射还能拿到泛型的类型](https://www.mianshiya.com/bank/1787463103423897602/question/1833434214495657985#heading-0)

---

### · 泛型方法里面的T 和 类上定义的 T 有什么关系？

看泛型参数声明的位置：

```java
class Box<T> {                    // T声明在类名后面，是类的泛型参数
    
    public T get() { }            // 这个T没有声明，是引用类的T
    
    public <T> T process(T t) { } // T声明在返回值前面，是方法自己的T
    
    public <E> E convert(E e) { } // E声明在返回值前面，是方法自己的E
}
```

**关键区别**：方法返回值前面有没有`<>`声明。

- `public T get()` — 没有`<>`，用的是类的T
- `public <T> T process(T t)` — 有`<T>`，是方法自己定义的T

举个例子：

```java
class Box<T> {
    private T value;
    
    public T get() {
        return value;  // 返回类的T类型
    }
    
    public <T> T process(T input) {
        return input;  // 这个T和上面的T完全无关
    }
}

Box<String> box = new Box<>();  // 类的T是String
box.get();                       // 返回String
box.process(123);                // 方法的T推断为Integer，和String无关
```

所以建议方法泛型用不同的字母，比如用E、R，避免和类的T混淆。

> [!quote] 参考
> [Java 泛型的作用是什么?](https://www.mianshiya.com/bank/1787463103423897602/question/1780933294628564993#heading-3)

---

### · 什么是Java泛型的上下界限定符？

上下界限定符用于限制泛型参数的类型范围。

**上界`<? extends T>`**：只能是T或T的子类，用于读取数据。

```java
// 只能读，不能写
List<? extends Number> list = new ArrayList<Integer>();
Number n = list.get(0);  // 可以读，返回Number
list.add(1);             // 编译错误，不能写
```

因为编译器只知道是Number的某个子类，不确定具体是Integer还是Double，所以不允许添加，避免类型不匹配。

**下界`<? super T>`**：只能是T或T的父类，用于写入数据。

```java
// 只能写，读出来是Object
List<? super Integer> list = new ArrayList<Number>();
list.add(1);              // 可以写Integer
Object o = list.get(0);   // 只能用Object接收
```

因为编译器知道至少是Integer的父类，放Integer肯定安全。但取出来不知道具体是什么类型，只能当Object。

**PECS原则**：Producer Extends，Consumer Super。

- 生产者（只读）用extends
- 消费者（只写）用super

```java
// 典型应用：Collections.copy
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
    // src是生产者，只读 → extends
    // dest是消费者，只写 → super
}
```

---

### · 协变和逆变

协变和逆变描述的是泛型类型与其参数类型之间的继承关系如何传递。

**协变（Covariance）**：子类型关系保持一致。Integer是Number的子类，`List<? extends Number>`可以接收`List<Integer>`。

```java
List<? extends Number> list = new ArrayList<Integer>();  // 协变
```

类型关系：Integer → Number，容器关系：`List<Integer>` → `List<? extends Number>`，方向一致。

**逆变（Contravariance）**：子类型关系相反。Integer是Number的子类，`List<? super Integer>`可以接收`List<Number>`。

```java
List<? super Integer> list = new ArrayList<Number>();  // 逆变
```

类型关系：Integer → Number，容器关系：`List<Number>` → `List<? super Integer>`，方向相反。

**不变（Invariance）**：没有通配符时，泛型是不变的。

```java
List<Number> list = new ArrayList<Integer>();  // 编译错误
```

虽然Integer是Number的子类，但`List<Integer>`不是`List<Number>`的子类。

**简单记忆**：

- 协变用extends，只读，类型关系同向
- 逆变用super，只写，类型关系反向
- 不变是默认行为，既能读也能写

---

### · 类型擦除对上下界限定符的影响

类型擦除后，上下界限定符会被擦除为边界类型。

**上界擦除为边界类型**：

```java
// 编译前
public void process(List<? extends Number> list) {
    Number n = list.get(0);
}

// 擦除后
public void process(List list) {
    Number n = (Number) list.get(0);
}
```

`<? extends Number>`擦除后，编译器插入强转为Number。

**下界擦除为Object**：

```java
// 编译前
public void add(List<? super Integer> list) {
    list.add(1);
}

// 擦除后
public void add(List list) {
    list.add(1);
}
```

`<? super Integer>`擦除为Object，因为下界没有明确的类型上限。

**读取时的差异**：

```java
List<? extends Number> extendsList;
Number n = extendsList.get(0);  // 擦除后强转为Number

List<? super Integer> superList;
Object o = superList.get(0);    // 擦除后只能是Object
```

所以extends能读出具体边界类型，super只能读出Object，这就是PECS原则的底层原因——类型擦除决定了读写能力。

---

### · 多重边界

泛型可以同时指定多个边界，用`&`连接。

```java
public <T extends Comparable<T> & Serializable> T process(T a, T b) {
    return a.compareTo(b) > 0 ? a : b;
}
```

T必须同时实现Comparable和Serializable两个接口。

**语法规则**：

- 只能有一个类，且必须放在第一位
- 接口可以有多个，用`&`连接

```java
// 正确：类在前，接口在后
<T extends Number & Comparable<T> & Serializable>

// 错误：类必须在第一位
<T extends Comparable<T> & Number>  // 编译错误
```

**类型擦除**：擦除为第一个边界类型。

```java
// 擦除前
<T extends Number & Comparable<T>>

// 擦除后，T变成Number
```

所以把最常用的类型放在第一位，可以减少编译器插入的强制类型转换。

**实际应用**：

```java
// 要求T既能比较又能序列化
public <T extends Comparable<T> & Serializable> void sort(List<T> list) {
    Collections.sort(list);
    // 可以安全地序列化list
}
```


> [!quote] 参考
> [什么是Java泛型的上下界限定符？](https://www.mianshiya.com/bank/1787463103423897602/question/1780933294636953601#heading-7)

---

### · 深拷贝的实现

深拷贝有几种常见实现方式。

**手动递归拷贝**：最可控，但代码繁琐。

```java
class User {
    private String name;
    private Address address;
    
    public User deepCopy() {
        User copy = new User();
        copy.name = this.name;  // String不可变，直接赋值
        copy.address = new Address(this.address.getCity());  // 手动创建新对象
        return copy;
    }
}
```

**实现Cloneable接口**：需要重写clone方法，对引用类型递归调用clone。

```java
class User implements Cloneable {
    private String name;
    private Address address;
    
    @Override
    protected User clone() throws CloneNotSupportedException {
        User copy = (User) super.clone();
        copy.address = this.address.clone();  // 引用类型也要clone
        return copy;
    }
}
```

**序列化方式**：简单通用，但性能较差。

```java
public static <T extends Serializable> T deepCopy(T obj) {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bos);
    oos.writeObject(obj);
    
    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
    ObjectInputStream ois = new ObjectInputStream(bis);
    return (T) ois.readObject();
}
```

**JSON序列化**：借助Jackson或Gson，简单但有类型限制。

```java
User copy = objectMapper.readValue(
    objectMapper.writeValueAsString(original), 
    User.class
);
```

> **Java标准库没有提供通用的深拷贝方法**，需要开发者自己实现。Spring的 BeanUtils 以及 Apache Commons的 BeanUtils 也是**浅拷贝**！

---

### · Cloneable接口的坑

Cloneable接口设计有很多问题，被认为是Java的历史遗留缺陷。

**接口是空的**：Cloneable没有定义任何方法，clone()方法在Object类里。实现Cloneable只是个标记，告诉JVM允许调用clone()。

```java
public interface Cloneable {
    // 什么都没有
}
```

**默认是浅拷贝**：Object.clone()只复制字段值，引用类型字段仍指向同一个对象。

```java
class User implements Cloneable {
    private List<String> tags;
    
    @Override
    protected User clone() throws CloneNotSupportedException {
        return (User) super.clone();  // tags还是同一个List
    }
}
```

**必须处理受检异常**：CloneNotSupportedException是受检异常，调用处必须捕获，很烦。

```java
try {
    User copy = user.clone();
} catch (CloneNotSupportedException e) {
    // 实现了Cloneable理论上不会抛，但必须写
}
```

**clone()是protected**：想让外部调用必须重写为public。

**继承链容易出问题**：子类忘记重写clone()，就会返回父类类型。

```java
class Parent implements Cloneable {
    @Override
    public Parent clone() { ... }
}

class Child extends Parent {
    // 忘记重写，clone()返回Parent类型
}
```

**推荐替代方案**：

- 拷贝构造器：`new User(original)`
- 静态工厂方法：`User.copyOf(original)`
- 序列化或JSON拷贝

《Effective Java》明确建议避免使用Cloneable。

---

### · 循环引用

循环引用是指两个或多个对象互相持有对方的引用，形成闭环。

```java
class User {
    private Department department;
}

class Department {
    private List<User> users;
}
```

User引用Department，Department又引用User，形成循环。

**深拷贝时的问题**：递归拷贝会死循环或栈溢出。

```java
// 拷贝User时要拷贝Department
// 拷贝Department时又要拷贝User
// 无限循环...
```

**序列化时的问题**：JSON序列化直接报栈溢出。

```java
objectMapper.writeValueAsString(user);  // StackOverflowError
```

**解决方案**：

**1. 用Map记录已拷贝的对象**：

```java
Map<Object, Object> copied = new IdentityHashMap<>();

public Object deepCopy(Object obj, Map<Object, Object> copied) {
    if (copied.containsKey(obj)) {
        return copied.get(obj);  // 已拷贝过，直接返回
    }
    Object copy = createCopy(obj);
    copied.put(obj, copy);  // 先记录再递归
    // 继续拷贝字段...
}
```

**2. JSON序列化用注解打断循环**：

```java
class User {
    @JsonManagedReference
    private Department department;
}

class Department {
    @JsonBackReference
    private List<User> users;
}
```

**3. 设计上避免双向引用**：

```java
// 只保留单向引用
class User {
    private Long departmentId;  // 只存ID，不存对象
}
```

实际开发中，能用单向引用就别用双向，减少复杂度。

---

### · 什么是Java的Integer缓存池？

Java的Integer缓存池是一个**性能优化机制**，用于缓存常用的Integer对象，避免重复创建。

- **核心原理**

当使用`Integer.valueOf()`方法或自动装箱时，Java会先检查缓存池：

```java
Integer a = 127;  // 自动装箱，实际调用 Integer.valueOf(127)
Integer b = 127;
System.out.println(a == b);  // true，指向同一个缓存对象

Integer c = 128;
Integer d = 128;
System.out.println(c == d);  // false，超出缓存范围，创建了新对象
```

- **缓存范围** 

**默认缓存 -128 到 127**，这个范围覆盖了大部分常用整数。可以通过JVM参数调整上限：

```bash
-XX:AutoBoxCacheMax=256  # 将上限扩展到256
```

但下限-128是固定的，不能修改。

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // 初始化时创建缓存数组
        int h = 127;
        // 可通过参数调整high值
        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);
    }
}
```

-128到127是**字节范围**（byte的取值范围），这些小整数在程序中使用频率极高，比如循环计数器、状态码等。缓存它们能显著减少对象创建开销和内存占用。

---

### · String 的常量池 和 Integer 的缓存池是一回事吗？

不是一回事，它们有本质区别：

**String 常量池（String Pool）**

```java
String s1 = "hello";  // 存储在字符串常量池
String s2 = "hello";  // 复用常量池中的对象
System.out.println(s1 == s2);  // true
```

- **位置**：在堆内存中有专门的区域（JDK 7+ 从永久代移到了堆）
- **作用范围**：全局的，JVM 级别共享
- **创建时机**：编译期字面量就确定，运行时也可以通过 `intern()` 加入
- **目的**：因为字符串不可变且使用频繁，避免重复创建相同内容的对象

**Integer 缓存池**

```java
Integer a = 127;  // 自动装箱，使用缓存
Integer b = 127;
System.out.println(a == b);  // true

Integer c = 128;  // 超出缓存范围
Integer d = 128;
System.out.println(c == d);  // false，创建了新对象
```

- **位置**：`Integer` 类内部的静态数组
- **作用范围**：仅限 -128 到 127 这个区间（可通过 `-XX:AutoBoxCacheMax` 调整上限）
- **创建时机**：类加载时一次性创建好所有缓存对象
- **目的**：优化常用小整数的自动装箱性能

---

### · Java 类加载过程是怎样的？

Java 类加载过程分为三个主要阶段：

```
加载(Loading) → 链接(Linking) → 初始化(Initialization)
                  ↓
        验证 → 准备 → 解析
```

1. **加载（Loading）**

通过类加载器将 `.class` 文件的字节码读入内存：

```java
// 触发类加载的时机
Class<?> clazz = Class.forName("com.example.User");  // 显式加载
User user = new User();  // 首次使用时加载
```

**做了三件事**：

- 通过类的全限定名获取二进制字节流
- 将字节流转化为方法区的运行时数据结构
- 在堆中生成对应的 `Class` 对象作为访问入口

2. **链接（Linking）**

**验证（Verification）**

确保字节码符合 JVM 规范，防止恶意代码：

```
- 文件格式验证（魔数 0xCAFEBABE 开头）
- 元数据验证（是否有父类、继承关系是否合法）
- 字节码验证（类型转换、跳转指令是否合法）
- 符号引用验证（引用的类、字段、方法是否存在）
```

**准备（Preparation）**

为类的**静态变量**分配内存并设置**默认初始值**：

```java
public class Example {
    private static int count = 100;      // 准备阶段：count = 0
    private static final int MAX = 200;  // 准备阶段：MAX = 200（final 常量直接赋值）
    private int value = 50;              // 实例变量不处理
}
```

**注意**：这里只是零值初始化（除了`static final`），真正赋值在初始化阶段。

**解析（Resolution）**

将符号引用转换为直接引用：

```java
// 编译后的字节码中是符号引用
invokevirtual #2  // Method java/io/PrintStream.println:(Ljava/lang/String;)V

// 解析后变成直接引用（内存地址）
invokevirtual 0x00007f8a1c001234
```

3. **初始化（Initialization）**

执行类构造器 `<clinit>()` 方法，真正给静态变量赋值：

```java
public class Parent {
    static int a = 10;
    static {
        System.out.println("Parent static block");
        a = 20;
    }
}

public class Child extends Parent {
    static int b = 30;
    static {
        System.out.println("Child static block");
    }
}

// 触发初始化
Child child = new Child();
```

---

### · 类加载的触发时机

1. **new 对象**

```java
User user = new User();
```

2. **访问静态变量/方法**（final 常量除外）

```java
int x = Demo.count;
Demo.show();
```

3. **反射调用**

```java
Class.forName("User");
```

4. **初始化子类，先初始化父类**
   
5. **JVM 启动的主类**（main 方法所在类）
   
6. **动态语言支持**（MethodHandle）
   

**`Class.forName()` 和 `ClassLoader.loadClass()` 的区别？**

```java
Class.forName("User");  // 加载 + 初始化
ClassLoader.loadClass("User");  // 只加载，不初始化
```

**访问子类静态变量会初始化父类吗？**

- 如果变量定义在父类：只初始化父类
- 如果变量定义在子类：父类、子类都初始化

---

### · 类加载器的层次结构

Java 类加载器采用**双亲委派模型**，形成层次分明的委托链：

```
Bootstrap ClassLoader（启动类加载器）
         ↑
Extension ClassLoader（扩展类加载器）
         ↑
Application ClassLoader（应用类加载器）
         ↑
Custom ClassLoader（自定义类加载器）
```

**Bootstrap ClassLoader** 是最顶层的加载器，由 C++ 实现，负责加载 `$JAVA_HOME/lib` 下的核心类库，如 `rt.jar`、`java.lang.*` 等。在 Java 代码中获取它会返回 `null`。

**Extension ClassLoader**（Java 9+ 改名为 Platform ClassLoader）加载 `$JAVA_HOME/lib/ext` 目录下的扩展类，或 `java.ext.dirs` 指定的路径。

**Application ClassLoader** 也叫 System ClassLoader，加载 classpath 下的类，是我们日常开发中最常接触的加载器。

**双亲委派的工作流程**：当一个类加载器收到加载请求时，它首先委托给父加载器处理，此时所有的类加载请求最终都应当传送到顶层的启动类加载器中，只有父加载器无法完成时，才自己尝试加载。

```java
protected Class<?> loadClass(String name, boolean resolve) {
    // 1. 检查是否已加载
    Class<?> c = findLoadedClass(name);
    if (c == null) {
        // 2. 委托父加载器
        if (parent != null) {
            c = parent.loadClass(name, false);
        } else {
            c = findBootstrapClassOrNull(name);
        }
        // 3. 父加载器加载失败，自己加载
        if (c == null) {
            c = findClass(name);
        }
    }
    return c;
}
```

这种设计的好处是保证核心类库的安全性——即使你自己写一个 `java.lang.String`，也不会被加载，因为 Bootstrap 已经加载了 JDK 的版本。

---

### · 打破双亲委派的场景

1. **SPI 机制**

最典型的例子是 JDBC。`DriverManager` 位于 `rt.jar`，由 Bootstrap ClassLoader 加载，但具体的数据库驱动（如 MySQL Driver）在 classpath 下，需要 Application ClassLoader 加载。

按双亲委派，父加载器加载的类无法访问子加载器加载的类，这就矛盾了。

**解决方案**：线程上下文类加载器（Thread Context ClassLoader）

```java
// DriverManager 中的实现
ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
// 内部使用 Thread.currentThread().getContextClassLoader()
```

父加载器通过线程上下文"向下"获取子加载器，完成加载。类似的还有 JNDI、JAXP 等 SPI 场景。


2. **热部署 / 热替换**

OSGi、Spring Boot DevTools、JRebel 等实现热部署时，需要卸载旧类、加载新类。

由于类的唯一性由**类加载器 + 全限定名**共同决定，实现热替换的方式是：丢弃旧的类加载器实例，创建新的类加载器重新加载类。

```java
// 简化示意
public void hotReload() {
    // 丢弃旧加载器（旧类随之卸载）
    this.classLoader = null;
    // 创建新加载器
    this.classLoader = new CustomClassLoader();
    // 重新加载
    Class<?> newClass = classLoader.loadClass("com.example.Service");
}
```

---

### · Tomcat 的类加载器跟标准的双亲委派有什么不同？

标准双亲委派

```
先委托父加载器 → 父加载不到 → 自己加载
```

Tomcat 的类加载器

```
先自己加载 → 自己加载不到 → 再委托父加载器
```

> [!quote] 参考
> [Java 类加载过程是怎样的？](https://www.mianshiya.com/bank/1787463103423897602/question/1780933294662119426)

---

### · 什么是Java的BigDecimal？

`BigDecimal` 是 Java 提供的**任意精度十进制数**，专门解决浮点数精度丢失问题。

```java
System.out.println(0.1 + 0.2);  // 输出 0.30000000000000004
```

`double` 和 `float` 用二进制存储，无法精确表示某些十进制小数。金融、支付等场景中这种误差是不可接受的。

1. **基本用法**

**创建时避免用 double 构造器**：

```java
// 错误 - 精度已经丢失了
BigDecimal bad = new BigDecimal(0.1);  // 0.1000000000000000055511151231...

// 正确
BigDecimal a = new BigDecimal("0.1");
BigDecimal b = BigDecimal.valueOf(0.1);  // 内部先转 String
```

**四则运算**：

```java
BigDecimal a = new BigDecimal("10.5");
BigDecimal b = new BigDecimal("3");

a.add(b);       // 13.5
a.subtract(b);  // 7.5
a.multiply(b);  // 31.5
a.divide(b, 2, RoundingMode.HALF_UP);  // 3.50
```

除法必须指定精度和舍入模式，否则遇到无限小数会抛 `ArithmeticException`。

2. **比较相等**

```java
BigDecimal x = new BigDecimal("1.0");
BigDecimal y = new BigDecimal("1.00");

x.equals(y);      // false，精度不同
x.compareTo(y);   // 0，数值相等
```

比较数值大小用 `compareTo()`，`equals()` 会同时比较精度。

> [!quote] 参考
> [什么是Java的BigDecimal？](https://www.mianshiya.com/bank/1787463103423897602/question/1780933294674702337#heading-0)

---

### BigDecimal 为什么能保证精度不丢失？

`BigDecimal` 的核心思想是**用整数 + 标度**来表示小数，完全避开二进制浮点数的精度问题。

1. **内部结构**

```java
public class BigDecimal {
    private final BigInteger intVal;  // 无标度值（整数部分）
    private final int scale;          // 标度（小数点位置）
}
```

比如 `123.45` 的存储方式：

```
intVal = 12345
scale = 2
实际值 = 12345 × 10^(-2) = 123.45
```

本质上就是把小数转成整数存储，整数运算是精确的。

2. **对比 double 的问题**

`double` 用 IEEE 754 标准，将数值拆成**符号位 + 指数 + 尾数**，用二进制存储。

`0.1` 在二进制中是无限循环小数：

```
0.1 (十进制) = 0.0001100110011001100... (二进制，无限循环)
```

64 位存不下无限小数，只能截断，精度就丢了。

而 `BigDecimal("0.1")` 的存储：

```
intVal = 1
scale = 1
实际值 = 1 × 10^(-1) = 0.1  （精确）
```

---

### · `BigDecimal.valueOf` 和 `new BigDecimal(String)` 有什么区别？

两者在精度上效果相同，区别主要在**实现方式**和**缓存机制**。

```java
// BigDecimal.valueOf(double)
public static BigDecimal valueOf(double val) {
    return new BigDecimal(Double.toString(val));
}

// new BigDecimal(String)
public BigDecimal(String val) {
    // 直接解析字符串
}
```

`valueOf(double)` 内部就是先转成 String 再构造，所以精度上和直接传 String 一样。

关键区别整数有缓存

```java
// BigDecimal.valueOf(long)
public static BigDecimal valueOf(long val) {
    if (val >= 0 && val < ZERO_THROUGH_TEN.length)
        return ZERO_THROUGH_TEN[(int)val];  // 返回缓存对象
    return new BigDecimal(null, val, 0, 0);
}
```

`valueOf(long)` 对 0~10 的整数做了缓存，不会创建新对象：

```java
BigDecimal a = BigDecimal.valueOf(5);
BigDecimal b = BigDecimal.valueOf(5);
System.out.println(a == b);  // true，同一个缓存对象

BigDecimal c = new BigDecimal("5");
BigDecimal d = new BigDecimal("5");
System.out.println(c == d);  // false，不同对象
```

简单说，`valueOf` 多了一层缓存优化，但对小数而言两者本质一样。项目中统一用一种风格就行，字符串字面量用构造器更直观，变量转换用 `valueOf` 更方便。


> [!quote] 扩展
> [[23. 分存元算方案]]

---

### · 使用 `new String("java")` 语句在 Java 中会创建多少个对象？

1. **最多创建 2 个对象**

**对象 1**：字符串常量池中的 `"java"`

编译时，`"java"` 作为字面量会进入 class 文件的常量池。类加载时，如果字符串常量池中没有 `"java"`，就会创建一个。

**对象 2**：堆中的 String 对象

`new String()` 必定在堆中创建一个新对象，它的内部 `char[]`（或 Java 9+ 的 `byte[]`）指向常量池中 `"java"` 的字符数组。

2. **可能只创建 1 个对象**

如果常量池中已经存在 `"java"`（比如之前的代码用过这个字面量），那就只创建堆中那个新对象。

```java
String a = "java";              // 常量池创建 "java"
String b = new String("java");  // 只创建堆中的对象，常量池已有
```

> [!quote] 参考
> [使用 `new String("java")` 语句在 Java 中会创建多少个对象？](https://www.mianshiya.com/bank/1787463103423897602/question/1780933294678896641#heading-7)

---

### · Java finally

`finally` 是 Java 异常处理机制中保证代码一定执行的块。

1. **基本用法**

```java
try {
    // 可能抛异常的代码
} catch (Exception e) {
    // 异常处理
} finally {
    // 无论是否异常，都会执行
    // 通常用于释放资源
}
```

典型场景是关闭资源：

```java
FileInputStream fis = null;
try {
    fis = new FileInputStream("file.txt");
    // 读取文件
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fis != null) {
        try { fis.close(); } catch (IOException e) {}
    }
}
```

2. `finally` 不执行的特殊情况

```java
// 1. JVM 退出
try {
    System.exit(0);
} finally {
    System.out.println("不会执行");
}

// 2. 线程被强制终止（如守护线程随 JVM 退出）

// 3. 无限循环或死锁在 try 块中
```

除了这些极端情况，`finally` 都会执行。

3. `finally` 与 `return` 的执行顺序

```java
public static int test() {
    try {
        return 1;
    } finally {
        System.out.println("finally 执行");
    }
}
// 输出 "finally 执行"，返回 1
// finally 在 return 之后、方法返回之前执行
```

**注意**：`finally` 中的 `return` 会覆盖 `try/catch` 的返回值：

```java
public static int test() {
    try {
        return 1;
    } finally {
        return 2;  // 覆盖，最终返回 2
    }
}
```


> [!quote] 参考
> [[24. return 的实际执行过程]]


4. `finally` 对返回值的影响

**基本类型**：`finally` 中修改不影响返回值

```java
public static int test() {
    int x = 1;
    try {
        return x;  // 返回值已确定为 1
    } finally {
        x = 2;     // 修改无效
    }
}
// 返回 1
```

**引用类型**：`finally` 中修改对象内容会生效

```java
public static StringBuilder test() {
    StringBuilder sb = new StringBuilder("a");
    try {
        return sb;
    } finally {
        sb.append("b");  // 修改对象内容
    }
}
// 返回 "ab"
```

原因是 `return` 时保存的是引用的副本，指向同一个对象。

5. `try-with-resources`（Java 7+）

更优雅的资源管理方式，自动调用 `close()`：

```java
try (FileInputStream fis = new FileInputStream("file.txt");
     BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {
    // 使用资源
} catch (IOException e) {
    e.printStackTrace();
}
// 自动关闭，无需 finally
```

资源必须实现 `AutoCloseable` 接口，关闭顺序是声明的逆序。

---

### · `finalize()` 是什么？

`finalize()` 是 Object 类的方法，GC 回收对象前会调用它，但执行时机不确定、性能差、还可能导致对象复活，Java 9 已废弃。资源释放应该用 `try-with-resources` 或显式 `close()`，不要依赖 `finalize()`。

> [!quote] 参考
> [[finalize()是什么？]]

---

### · final 修饰的变量一定线程安全吗？

1. 基本类型

```java
final int count = 10;
```

值不可变，天然线程安全。

2. 不可变对象

```java
final String name = "java";
final Integer num = 100;
```

`String`、`Integer` 等本身不可变，引用也不可变，安全。

3. 可变对象

```java
final List<String> list = new ArrayList<>();
```

`final` 只保证引用不变（不能指向其他对象），但对象内容可以被多线程同时修改：

```java
// 线程 A
list.add("a");

// 线程 B
list.add("b");

// 可能数据错乱或抛异常
```

**总结**

`final` 保证的是**引用不可变**，不是**内容不可变**。可变对象要线程安全，还是得用同步机制或并发容器：

```java
final List<String> list = Collections.synchronizedList(new ArrayList<>());
// 或
final List<String> list = new CopyOnWriteArrayList<>();
```

---

### · 如果一个线程在 Java 中被两次调用 `start()` 方法，会发生什么？

第二次调用会抛出 `IllegalThreadStateException`。

```java
Thread t = new Thread(() -> System.out.println("running"));
t.start();  // 正常启动
t.start();  // 抛出 IllegalThreadStateException
```

Thread 内部维护了一个状态字段 `threadStatus`，`start()` 方法会检查：

```java
public synchronized void start() {
    if (threadStatus != 0)  // 0 表示 NEW 状态
        throw new IllegalThreadStateException();
    // ...启动线程
}
```

线程调用 `start()` 后状态从 NEW 变成 RUNNABLE，执行完 `run()` 方法后变成 TERMINATED。不管是 RUNNABLE 还是 TERMINATED，再调 `start()` 都会因为 `threadStatus != 0` 而抛异常。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E4%B8%8Estart()%E5%BC%82%E5%B8%B8.png" alt="Java线程状态转换与start()异常" style="zoom: 25%;" />


- **线程状态流转**

```
NEW → start() → RUNNABLE → 运行结束 → TERMINATED
```

状态是单向的，TERMINATED 后不能回到 NEW，所以线程不可复用。

想多次执行同样的任务，用线程池：

```java
ExecutorService pool = Executors.newFixedThreadPool(1);
Runnable task = () -> System.out.println("running");

pool.submit(task);  // 第一次
pool.submit(task);  // 第二次，没问题
```

线程池复用的是池中的线程，不是同一个 Thread 对象反复 start()。

---

### · Java 线程的 6 种状态

Java 线程有 6 种状态，定义在 `Thread.State` 枚举中。

- **各状态说明**

```
        start()
NEW ─────────────→ RUNNABLE
                      ↓↑
        ┌─────────────┴─────────────┐
        ↓                           ↓
   BLOCKED               WAITING / TIMED_WAITING
        ↓                           ↓
        └─────────────┬─────────────┘
                      ↓
                 TERMINATED
```

1. **NEW**：线程对象刚创建，还没调 `start()`。此时只是个普通 Java 对象，操作系统层面的线程还不存在。
    
2. **RUNNABLE**：调了 `start()` 之后进入，包含了操作系统层面的 Ready 和 Running 两种状态。因为 JVM 不区分"等待 CPU 时间片"和"正在执行"，统一叫 RUNNABLE。所以即使线程在等 CPU 调度，状态也是 RUNNABLE 而不是"就绪"。
    
3. **BLOCKED**：等待获取 `synchronized` 锁时进入，拿到锁就回到 RUNNABLE。注意只有 `synchronized` 会导致 BLOCKED，`ReentrantLock` 等待时是 WAITING 状态（因为底层用的 `LockSupport.park()`）。
    
4. **WAITING**：调用 `Object.wait()`、`Thread.join()`、`LockSupport.park()` 后进入，必须被其他线程显式唤醒（`notify()`、`unpark()` 或等待的线程结束）。
    
5. **TIMED_WAITING**：和 WAITING 类似，但指定了超时时间，比如 `Thread.sleep(1000)`、`Object.wait(1000)`，时间到了自动醒。也可以提前被唤醒。
    
6. **TERMINATED**：`run()` 执行完毕或者抛了未捕获异常，线程生命周期结束。状态不可逆，无法再次 `start()`。

- **BLOCKED 和 WAITING 的区别**

**BLOCKED**：被动等锁，锁释放后自动竞争

```java
synchronized (lock) { }  // 别人持有 lock，我就 BLOCKED
```

**WAITING**：主动等待，需要被唤醒

```java
lock.wait();      // 主动放弃锁，等 notify() 唤醒
otherThread.join(); // 等另一个线程结束
```

---

### · 操作系统中的线程状态与Java中的线程状态划分有什么不同？

操作系统区分 Ready（等 CPU 时间片）和 Running（正在执行），Java 因为跑在 JVM 之上感知不到这个差异，统一合并为 RUNNABLE。而对于等待状态，操作系统统一视为 Blocked，Java 则细分为 BLOCKED（等 synchronized 锁）、WAITING（主动等待需唤醒）、TIMED_WAITING（带超时的等待）三种，方便排查线程卡在哪种等待上。

> [!quote] 参考
> [如果一个线程在 Java 中被两次调用 `start()` 方法，会发生什么？](https://www.mianshiya.com/bank/1787463103423897602/question/1800331617560240129#heading-5)

---

### · 栈和队列在java中的区别是什么？

栈和队列是两种不同的数据结构，核心区别在于元素的进出顺序。

|特性|栈 (Stack)|队列 (Queue)|
|---|---|---|
|顺序|LIFO（后进先出）|FIFO（先进先出）|
|比喻|摞盘子，后放的先拿|排队，先来的先走|
|入口|栈顶|队尾|
|出口|栈顶|队头|


> [!quote] 参考
> [栈和队列在java中的区别是什么？](https://www.mianshiya.com/bank/1787463103423897602/question/1800343420860178433#heading-0)

---

### · 什么是Java的Optional类？他有什么作用？

`Optional` 是 Java 8 引入的容器类，用于优雅地处理可能为 null 的值，避免 `NullPointerException`。让"值可能不存在"这件事显式化，通过链式调用优雅处理 null，避免层层嵌套的 null 检查。

> [!quote] 参考
> [什么是Java的Optional类？他有什么作用？](https://www.mianshiya.com/bank/1787463103423897602/question/1800345746421391361#heading-10)

---

### · Java I/O 流

Java 的 I/O 流是一套用于读写数据的类库，程序通过它从文件、网络等地方读取数据，或将数据写入目标。

I/O 流按数据单位分为两大类：

- **字节流**  
  处理 8 位原始字节，适合图片、视频、压缩包等二进制文件。核心类：`InputStream` 和 `OutputStream`。

- **字符流**  
  处理 16 位 Unicode 字符，专门用于文本文件的读写。核心类：`Reader` 和 `Writer`。
---

### · Java I/O 流的设计思想

Java I/O 流的设计基于**装饰器模式**，通过流的层层包装来扩展功能。每个流只负责一个功能，通过层层包装自由组合，避免了继承带来的类爆炸问题。

1. **核心思想**

不是用继承来扩展功能，而是用组合——把一个流包装进另一个流：

```java
// 层层包装
InputStream is = new FileInputStream("file.txt");           // 基础：读文件
InputStream bis = new BufferedInputStream(is);              // +缓冲
DataInputStream dis = new DataInputStream(bis);             // +读基本类型

// 通常写成一行
DataInputStream dis = new DataInputStream(
    new BufferedInputStream(
        new FileInputStream("file.txt")));
```

每一层只负责一个功能，自由组合。

2. **为什么不用继承**

如果用继承来扩展功能：

```
InputStream
├── FileInputStream
├── BufferedInputStream
├── DataInputStream
├── BufferedFileInputStream          // 组合爆炸
├── BufferedDataInputStream
├── BufferedDataFileInputStream
└── ...
```

类的数量会爆炸式增长。

3. **装饰器模式的结构**

```
InputStream (抽象基类)
    ↑
FileInputStream (节点流，数据源)
    ↑
FilterInputStream (装饰器基类)
    ↑
BufferedInputStream / DataInputStream (具体装饰器)
```

装饰器持有一个被装饰对象的引用，在调用时增加自己的逻辑：

```java
public class BufferedInputStream extends FilterInputStream {
    private byte[] buf;  // 缓冲区
    
    public BufferedInputStream(InputStream in) {
        super(in);  // 持有被装饰的流
    }
    
    public int read() {
        // 先从缓冲区读，没有再调用 in.read() 填充缓冲区
    }
}
```

---
### · 缓冲流为什么能提速

不加缓冲的流每读一个字节就要调一次系统调用，读 1MB 的文件得调用上百万次，开销巨大。`BufferedInputStream` 内部维护了一个 8192 字节的 `byte` 数组，一次性从操作系统读一大块数据进来，后续的 `read` 直接从内存数组里取，系统调用次数一下子降到几百次，性能能提升几十倍。写入同理，`BufferedOutputStream` 搬够一批数据再统一刷到磁盘。

缓冲区大小可以自定义，默认 8192 字节，大文件可以适当调大：

```java
// 默认 8KB 缓冲
new BufferedInputStream(fis);

// 自定义 32KB 缓冲
new BufferedInputStream(fis, 32768);
```

但也不是越大越好，太大了占内存，收益递减。一般默认值够用，特殊场景再调。

---
### · 字节流和字符流的选择

处理**纯文本文件**用字符流，因为它帮你处理好了编码问题，不用自己折腾字节到字符的转换。处理**二进制文件**必须用字节流，用字符流读图片会导致数据损坏，因为字符流会尝试把字节按编码解析成字符，遇到不合法的字节序列就会出问题。

还有个常见场景是网络传输，虽然传的是字节，但如果协议层约定了文本格式，可以用 `InputStreamReader` 把 `Socket` 的字节流包装成字符流来处理。


> [!quote] 参考
> [Java I/O 流](https://www.mianshiya.com/bank/1787463103423897602/question/1800347227602100226#heading-4)

---

### 什么是Java中的迭代器（`Iterator`）？

迭代器是 Java 提供的统一遍历集合的接口，通过 `hasNext()` 判断是否有下一个元素、`next()` 获取元素、`remove()` 删除当前元素。它的好处是不暴露集合内部结构就能遍历，不管底层是数组还是链表都用同样的方式访问。`for-each` 循环本质上就是迭代器的语法糖。另外，遍历时想删除元素必须用迭代器的 `remove()`，直接用集合的 `remove()` 会抛 `ConcurrentModificationException`。


---
### · fail-fast 机制

fail-fast 是 Java 集合的一种错误检测机制，遍历时发现集合被修改会立即抛出 `ConcurrentModificationException`，快速失败而不是继续执行产生不可预期的结果。

集合内部维护一个 `modCount` 计数器，每次增删都会 +1。迭代器创建时记录当前值为 `expectedModCount`，每次 `next()` 时检查两者是否相等：

```java
final void checkForComodification() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
}
```

---
### · fail-safe 机制

fail-safe 是与 fail-fast 相对的机制，遍历时不会因为集合被修改而抛异常，保证遍历安全完成。遍历的是集合的**副本或快照**，修改操作作用在原集合上，两者互不干扰。

**CopyOnWriteArrayList**：写时复制

```java
List<String> list = new CopyOnWriteArrayList<>(Arrays.asList("a", "b", "c"));

for (String s : list) {
    list.add("d");  // 不抛异常，写入新数组
    System.out.println(s);  // 遍历的是旧数组快照
}
// 输出 a b c，遍历期间的修改看不到
```

**ConcurrentHashMap**：分段机制

```java
Map<String, Integer> map = new ConcurrentHashMap<>();
map.put("a", 1);

for (String key : map.keySet()) {
    map.put("b", 2);  // 不抛异常
}
```

---

