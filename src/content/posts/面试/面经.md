---
title: 面经
category: 面试
tags:
  - 面试
published: 2026-01-29
updated: 2026-01-29
draft: true
---
---
## 1. Java基础

### · 序列化和反序列化是什么？

**序列化（Serialization）** 是将Java对象转换为字节序列（字节流）的过程，这样对象就可以被保存到文件、数据库中，或者通过网络传输。**反序列化（Deserialization）** 则是相反的过程，将字节序列（字节流）恢复为Java对象。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260129220900991.png" alt="image-20260129220900991" style="zoom: 33%;" />

1. **如何实现序列化？**

类必须实现`Serializable`接口，这个相当于一个许可证，没它 JDK 序列化机制不会让你序列化。

> 这接口是个空接口，一行代码都没有，纯粹就是个标记。JDK 序列化源码里有这么一段逻辑：除了 `String`、数组和枚举这几个特殊类型，其他对象要序列化必须实现 `Serializable`，否则直接抛 `NotSerializableException`。

2. **如何避免某些属性序列化？**

`transient` 关键字修饰的字段不会被序列化，序列化的时候会自动跳过。

> `transient` 字段在反序列化后，不是“保留旧值”，而是被赋成“类型的默认值”。

3. **如何保证序列化够稳？**

显式定义 `serialVersionUID`，相当于给类打个版本戳，防止改了类结构后反复序列化旧数据时报错。

> 这就等于你在说：“不管我内部怎么小改，只要我没手动改 `serialVersionUID`，就请你当成是同一个版本。”

> [!quote] 详情参考
> [[如何保证序列化够稳？]]

---

### · 对象为什么不能直接传输？

对象在内存中包含 对象数据（字段值）、内存地址引用、方法指针、虚拟方法表（vtable）等元数据，这些信息在不同的JVM进程中完全不同，无法直接复制。

无论是网络传输还是文件存储，底层只能处理连续的字节序列（byte stream），不理解Java对象的结构。

---

### · 静态变量参与序列化吗？

静态变量不参与序列化。

静态变量属于**类本身**，而不是对象实例。序列化是保存**对象的状态**，静态变量不是对象状态的一部分。反序列化后，静态变量的值**完全取决于当前JVM中类的静态变量值**，与序列化时的值无关。

---

### · 如果父类没有实现`Serializable`，子类实现了，序列化子类对象时父类对象会如何？

父类未实现 `Serializable` 时，序列化会"跳过"父类字段，反序列化时通过调用父类无参构造方法来初始化父类部分，所以父类字段会恢复为初始值而非序列化时的值。**如果父类没有无参构造方法，反序列化会直接失败，抛出 `InvalidClassException` 异常**。

---

### · JDK 序列化的问题

JDK 自带的序列化虽然用起来简单，但生产环境很少直接用，主要有这几个硬伤：

1. **性能差**：序列化后的字节流体积大，序列化/反序列化速度慢
2. **跨语言不友好**：只有 Java 能读懂，无法与 Go、Python 等语言直接互通
3. **安全风险**：存在反序列化漏洞，可能被恶意利用执行任意代码

所以实际项目中，RPC 框架一般用 Protobuf、Hessian、Kryo 这类专门的序列化框架，性能更好、体积更小。JSON 序列化虽然性能一般，但可读性好，在 HTTP API 场景中使用广泛。

|序列化方式|优点|缺点|典型场景|
|---|---|---|---|
|JDK 原生|使用简单|性能差、体积大、有安全风险|小项目、临时方案|
|JSON|可读性好、跨语言|性能一般、体积较大|HTTP API、配置文件|
|Protobuf|高性能、体积小|需要定义 .proto 文件|gRPC、高性能 RPC|
|Hessian|性能较好、使用简单|跨语言支持有限|Dubbo 默认序列化|
|Kryo|高性能、体积小|仅支持 Java|游戏服务器、缓存|

---

### · 为什么说反序列化是 Java 安全漏洞的重灾区？

反序列化会触发对象的构造过程，如果攻击者构造恶意的字节流，就能让某些类的特定方法被执行，从而造成远程代码执行（RCE）。

典型案例是利用 Apache Commons Collections、Fastjson 等库中的 **gadget chain**（利用链）。攻击者只需找到一条从反序列化入口通往危险方法（如 `Runtime.exec()`）的调用链，就能在服务器上执行任意命令，比如反弹 shell、读取敏感文件等。

**防御手段：**

1. **及时升级**：修复 Commons Collections、Fastjson 等已知存在漏洞的依赖库
2. **白名单机制**：配置反序列化白名单，只允许可信类进行反序列化
3. **替代方案**：使用 JSON、Protobuf 等更安全的序列化方式替代 Java 原生序列化
4. **网络隔离**：不直接暴露反序列化接口到公网

---
### · Java 中 Exception 和 Error 有什么区别?

`Exception` 和 `Error` 都是 `Throwable` 的子类，但它们的用途和处理方式完全不同。

> 只有继承了 `Throwable` 的对象才能被 `throw` 和 `catch`。

**Exception（异常）**

- **可预期的问题**，程序可以捕获并处理；
- 分为受检异常（`Checked Exception`）和非受检异常（`Unchecked Exception`）；
- 应该被 `try-catch` 捕获或通过 `throws` 声明。

> [!tip] 
> `Checked Exception`: 继承自 `Exception` 但不继承 `RuntimeException`，编译时必须显式处理，要么 `try-catch` 要么 `throws` 声明抛出，比如 `IOException`、`SQLException`。
> 
> `Unchecked Exception`: 继承自 `RuntimeException`，不需要显式捕获，运行时才抛出，比如 `NullPointerException`、`IndexOutOfBoundsException`。

**Error（错误）**

- **严重的系统级问题**，程序通常无法处理；
- 都是非受检的（继承自 `Error`）；
- 不应该被捕获，程序应该终止。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260130144522567.png" alt="image-20260130144522567" style="zoom: 33%;" />

---

### · 什么是Java多态特性？

多态（Polymorphism）是面向对象编程的三大特性之一（封装、继承、多态），指的是**同一个方法调用，在不同对象上会有不同的表现形式**。

> 简单来说：父类引用指向子类对象，调用方法时会执行子类的实现。

要实现多态，必须满足以下条件：

1. **继承关系**：子类继承父类或实现接口
	
2. **方法重写**：子类重写父类的方法
	
3. **父类引用指向子类对象**：向上转型

---

### · 编译时多态和运行时多态

**编译时多态（静态多态）**

通过**方法重载（Overload）** 实现，在编译阶段就能确定调用哪个方法。同一个类中，方法名相同，参数列表不同（参数个数、类型或顺序不同），编译器根据方法签名在编译时就能确定调用哪个方法，也叫**静态绑定**或**早期绑定**。

**运行时多态（动态多态）**

通过**方法重写（Override）** 实现，在运行时才能确定调用哪个方法。父类引用指向子类对象，子类重写父类的方法。运行时根据对象的实际类型决定调用哪个方法，也叫**动态绑定**或**晚期绑定**。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260130150850155.png" alt="image-20260130150850155" style="zoom: 50%;" />

---
### · 虚方法表的底层原理（简要概括）

虚方法表是 JVM 为每个类构建的方法地址索引表，用于实现运行时多态。当子类重写父类方法时，会在虚方法表的相同索引位置替换为自己的方法地址。多态调用时，JVM 根据对象的实际类型找到对应的虚方法表，通过索引直接定位方法地址并调用，实现 O(1) 的快速查找，这就是 Java 多态"运行时动态绑定"的底层实现机制。

> [!quote] 详情参考
> [[虚方法表的底层原理]]

---

### · Java中参数传递是值传递还是引用传递？

**Java 中只有值传递（Pass by Value），没有引用传递。**

- **值传递**：传递的是变量值的副本，修改副本不影响原变量。
- **引用传递**：传递的是变量本身的引用的副本（**内存地址值**），修改会影响原变量。

> **Java 的规则**：无论基本类型还是对象类型，传递的都是值的副本。

---
### · 基本类型与引用类型的区别？

**基本类型**包括 `byte`、`short`、`int`、`long`、`float`、`double`、`char`、`boolean` 共 8 种。作为局部变量时，基本类型的值直接存储在栈内存中；作为成员变量时，存储在堆内存的对象中。方法传参时传递的是值的副本，方法内的修改不影响原始变量。

**引用类型**包括类、接口、数组等。引用类型的变量存储的是对象在堆内存中的地址（引用值）。方法传参时传递的是地址值的副本，因此方法内可以通过这个副本引用修改对象的内容，但无法改变原引用变量指向的对象。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260201145710540.png" alt="image-20260201145710540" style="zoom: 50%;" />


> [!quote] 详情参考
> [[基本类型与引用类型在 JVM 存储位置]]

---

### · `String` 作为参数传递后在方法里修改了但为什么原来的变量没变？

`String` 是不可变类，方法里对 `String` 做任何拼接或替换操作，实际上是创建了一个新的 `String` 对象，然后让方法内的局部引用指向这个新对象。原来的引用还是指向老对象，压根没动过。这不是传引用还是传值的问题，而是 `String` 本身的不可变性决定的。

> [!quote] 详情参考
> [[Java中的不可变类]]

---
### · 为何Java不支持多重继承？

Java不支持多重继承主要是为了避免**菱形继承问题**。当一个类同时继承两个父类，而这两个父类又继承自同一个祖先类时，子类会面临方法调用歧义、字段重复、构造顺序混乱等问题。C++允许多重继承但把这些复杂性留给程序员处理，Java则选择了更简洁的方案：**单继承加多接口实现**。这样既保持了继承链的清晰，又通过接口获得了多态能力。Java 8引入接口默认方法后虽然也可能产生冲突，但编译器会强制开发者显式解决，而非隐式选择。这是Java在灵活性和简单性之间做出的刻意取舍。

> [!quote] 参考
> [[Java为何不支持多重继承]]

---

### · 方法重载和方法重写之间的区别

**方法重载（Overloading）** 是在同一个类中定义多个同名方法，但参数列表不同（参数类型、个数或顺序）。编译器在编译期根据调用时传入的参数类型决定调用哪个方法，属于**编译时多态**。重载与返回值类型无关，仅靠返回值不同无法构成重载。

```java
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
}
```

**方法重写（Overriding）** 是子类重新定义父类中已有的方法，要求方法签名完全相同（方法名、参数列表一致），返回值类型相同或是父类返回值的子类型。JVM在运行时根据对象的实际类型决定调用哪个版本，属于**运行时多态**。重写的方法访问权限不能比父类更严格，抛出的异常不能比父类更宽泛。

```java
class Animal {
    void speak() { System.out.println("..."); }
}

class Dog extends Animal {
    @Override
    void speak() { System.out.println("汪汪"); }
}
```

简单来说，重载是**横向扩展**同一个类的方法能力，重写是**纵向覆盖**父类的行为实现。重载发生在编译期、同一类内，重写发生在运行期、父子类之间。

---

### · 为何静态方法不能被重写？

*静态方法属于类本身而非对象实例，它在编译期就根据引用类型确定了调用哪个方法，这与重写所依赖的运行时多态机制相矛盾。* 重写的本质是子类对象在运行时根据实际类型动态选择方法实现，而静态方法的调用不依赖任何对象，自然无法参与这种动态绑定。当子类定义了与父类签名相同的静态方法时，这只是 **方法隐藏（Method Hiding）** 而非重写——父类的静态方法并没有被覆盖，两个方法各自独立存在于各自的类中，调用哪个完全取决于编译时的引用类型。

```java
class Parent {
    static void hello() { System.out.println("Parent"); }
}

class Child extends Parent {
    static void hello() { System.out.println("Child"); }
}

Parent p = new Child();
p.hello();  // 输出 "Parent"，而非 "Child"
```

如果这是真正的重写，应该输出"Child"，但实际输出"Parent"，因为编译器只看到`p`的类型是`Parent`就直接绑定了`Parent.hello()`。这也是为什么IDE会建议用类名而非实例来调用静态方法——静态方法本就与对象无关，通过实例调用反而容易造成误解。

---

### · 方法重载时传入`null`会调用哪个方法？

当重载方法都能接受null时，编译器会选择**参数类型最具体**的那个方法。

```java
void test(Object obj) { System.out.println("Object"); }
void test(String str) { System.out.println("String"); }

test(null);  // 输出 "String"
```

因为String是Object的子类，类型更具体，所以编译器选择了String版本。

但如果存在两个同级别的类型，编译器无法判断谁更具体，就会报错：

```java
void test(String str) { System.out.println("String"); }
void test(Integer num) { System.out.println("Integer"); }

test(null);  // 编译错误：引用不明确
```

String和Integer没有继承关系，编译器无法抉择。解决办法是显式转型告诉编译器你的意图：

```java
test((String) null);   // 输出 "String"
test((Integer) null);  // 输出 "Integer"
```

这个行为的本质是Java的**最具体匹配原则**：编译器在所有可行的重载方法中，选择参数类型在继承层次上最接近实参类型的那个。null可以赋值给任何引用类型，所以所有接受引用类型的重载都可行，最终选择类型层次最深的那个。

---

### · 什么是内部类

内部类是定义在另一个类内部的类，它可以访问外部类的成员（包括私有成员），用于实现更紧密的封装和逻辑组织。Java有四种内部类：

- **成员内部类**

定义在外部类的成员位置，不带`static`修饰，与实例字段平级，可以访问外部类的所有成员变量，包括`private`。它持有外部类实例的引用，必须依附于外部类对象存在。

```java
class Outer {
    private String name = "外部类";
    
    class Inner {
        void show() {
            System.out.println(name);  // 可访问外部类私有成员
        }
    }
}

// 创建方式
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
```

- **静态内部类**

用`static`修饰的内部类，不持有外部类实例的引用，只能访问外部类的静态成员。它本质上是一个独立的类，只是命名空间嵌套在外部类中。

```java
class Outer {
    private static String staticName = "静态成员";
    
    static class StaticInner {
        void show() {
            System.out.println(staticName);  // 只能访问静态成员
        }
    }
}

// 创建方式，不依赖外部类实例
Outer.StaticInner inner = new Outer.StaticInner();
```

- **局部内部类**

定义在方法或代码块内部，作用域仅限于该方法或代码块。它可以访问外部类成员和所在方法的局部变量（必须是`final`或 等效`final`）。

```java
class Outer {
    void doSomething() {
        final int count = 10;
        
        class LocalInner {
            void show() {
                System.out.println(count);
            }
        }
        
        new LocalInner().show();
    }
}
```

- **匿名内部类**

没有名字的局部内部类，用于快速实现接口或继承类，常见于回调和事件处理。

```java
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("按钮被点击");
    }
});
```

Java 8之后，函数式接口的匿名内部类可以用Lambda简化：

```java
button.addActionListener(e -> System.out.println("按钮被点击"));
```

|类型|能否访问外部类实例成员|创建方式|典型用途|
|---|---|---|---|
|成员内部类|能|依赖外部类实例|紧密关联的辅助类|
|静态内部类|不能（只能访问静态成员）|独立创建|Builder模式、逻辑分组|
|局部内部类|能|方法内部使用|临时封装逻辑|
|匿名内部类|能|声明同时实例化|回调、事件监听|

---

### · 内部类的底层实现

内部类是Java语言层面的特性，JVM本身并不认识内部类。编译器会将内部类编译成独立的class文件，并通过一些机制来维持内部类与外部类之间的关系。

- **成员内部类**

编译后会生成`Outer$Inner.class`文件，编译器自动为内部类添加一个指向外部类实例的引用字段和相应的构造器参数。

```java
class Outer {
    private String name = "外部类";
    
    class Inner {
        void show() {
            System.out.println(name);
        }
    }
}
```

编译器实际生成的内部类大致等价于：

```java
class Outer$Inner {
    final Outer this$0;  // 编译器自动添加的外部类引用
    
    Outer$Inner(Outer outer) {
        this.this$0 = outer;
    }
    
    void show() {
        System.out.println(this$0.name);
    }
}
```

访问外部类私有成员时，编译器会在外部类中生成合成的访问方法（synthetic method）：

```java
class Outer {
    private String name;
    
    // 编译器生成的桥接方法
    static String access$000(Outer outer) {
        return outer.name;
    }
}
```

- **静态内部类**

同样生成独立的class文件，但由于没有外部类实例引用，结构更简单，和普通类几乎一样，只是类名带有`Outer$StaticInner`的前缀。

```java
class Outer$StaticInner {
    // 没有this$0字段
    // 就是一个普通类
}
```

- **局部内部类**

编译后生成`Outer$1LocalInner.class`，数字用于区分同名局部类。它捕获的局部变量会被复制为内部类的字段：

```java
void doSomething() {
    final int count = 10;
    
    class LocalInner {
        void show() {
            System.out.println(count);
        }
    }
}
```

实际编译为：

```java
class Outer$1LocalInner {
    final Outer this$0;
    final int val$count;  // 捕获的局部变量副本
    
    Outer$1LocalInner(Outer outer, int count) {
        this.this$0 = outer;
        this.val$count = count;
    }
}
```

这就是为什么被捕获的局部变量必须是final或等效final——内部类持有的是变量值的副本，如果原变量能修改，两边数据就不一致了。

- **匿名内部类**

编译后生成`Outer$1.class`、`Outer$2.class`等，按出现顺序编号。本质和局部内部类相同，只是没有显式类名。

---

### · 成员内部类和静态内部类如何选？

如果内部类需要访问外部类的实例成员，就用成员内部类；如果不需要，优先用静态内部类。原因很简单，成员内部类会隐式持有外部类的引用，可能导致外部类无法被 GC 回收，造成内存泄漏。Android 开发里的 Handler 内存泄漏就是典型案例。

---
### · 匿名内部类访问局部变量为什么必须是`final`？

因为匿名内部类和局部变量的生命周期不同。局部变量存在于栈上，方法执行结束就销毁了；但匿名内部类的实例可能在方法结束后仍然存活，比如作为回调被其他对象持有。为了让内部类在方法结束后还能访问这个变量，编译器会在内部类中创建一个字段来保存该变量值的副本。

既然是副本，就存在数据一致性问题——如果允许修改原变量，内部类中的副本不会同步更新，两边数据就不一致了。Java选择通过强制final来从源头避免这个问题：变量不可变，副本就永远和原值一致。

Java 8之后不再要求显式写final，但变量必须是"等效final"，即实际上没有被修改过。这只是语法上的放宽，底层机制完全一样。

---
### · Java中String、StringBuffer、StringBuilder 的区别是什么？

**String** 是不可变类，底层的`char`数组被`final`修饰，每次修改都会创建新对象。它线程安全，适合字符串常量或很少修改的场景。

**StringBuilder** 是可变的字符序列，修改操作直接在原对象上进行，不创建新对象。它不是线程安全的，但性能最好，适合**单线程**下频繁拼接字符串。

**StringBuffer** 和StringBuilder功能完全一样，区别在于所有方法都加了`synchronized`关键字，线程安全但性能稍差，适合**多线程**环境。

简单选择：优先用StringBuilder，需要线程安全时用StringBuffer，字符串基本不变时用String。实际开发中StringBuffer用得很少，因为字符串拼接操作通常发生在单个方法内部，不涉及多线程竞争。

---
### · 为什么String要设计成不可变？

**安全性**。String广泛用于敏感场景，比如文件路径、数据库连接URL、网络地址、类加载的类名等。如果String可变，传递给方法后被意外或恶意修改，会造成严重的安全隐患。不可变保证了传递出去的字符串不会被篡改。

**支持字符串常量池**。JVM维护一个字符串常量池来复用字符串对象，相同内容的字符串字面量指向同一个对象。这能显著节省内存，但前提是字符串不可变——如果一个引用能修改字符串内容，所有共享这个对象的引用都会受影响。

**hashCode缓存**。String的hashCode在首次计算后会被缓存，因为内容不会变，hashCode永远不变。这让String非常适合作为HashMap的key，查找效率高且安全。如果可变，放入HashMap后内容被修改，hashCode变了，这个键值对就再也找不到了。

附带的好处是**天然线程安全**，多线程环境下可以自由共享String对象而无需同步。

---
### · StringBuilder底层实现

`StringBuilder`继承自`AbstractStringBuilder`，核心是一个`char`数组加一个`count`变量记录实际字符数。

```java
abstract class AbstractStringBuilder {
    char[] value;  // JDK 9之后改为byte[]
    int count;     // 实际字符数量
}
```

`append`操作先检查容量是否足够，不够就扩容，然后把新内容拷贝到数组末尾并更新`count`。整个过程都是在原数组上操作，不创建新对象。

扩容策略是原容量乘2再加2。假设当前容量是16，扩容后就是34；如果仍不够，就直接扩到所需大小。扩容涉及创建新数组和拷贝旧数据，开销不小，所以创建`StringBuilder`时最好预估最终长度，通过构造器参数指定初始容量。

JDK 9把`String`、`StringBuilder`、`StringBuffer`底层的`char`数组全换成了`byte`数组，同时加了一个`coder`字段标记编码方式。

```java
// JDK 9+
public final class String {
    private final byte[] value;
    private final byte coder;  // 0=LATIN1, 1=UTF16
}
```

改动原因是大部分字符串实际上都是英文、数字这些Latin-1字符，一个字节就够了。以前用`char`数组，每个字符固定占2字节，纯英文字符串浪费一半内存。改成`byte`数组后，Latin-1字符串内存占用直接减半。
这个优化叫Compact Strings，对内存敏感或需要处理海量字符串的场景提升明显。

---
### · 编译器的字符串拼接优化

编译器会对字符串拼接进行优化，但优化程度取决于拼接内容。

**纯字面量拼接**，编译器直接在编译期合并成一个字符串常量：

```java
String s = "Hello" + " " + "World";
// 编译后等价于
String s = "Hello World";
```

**包含变量的拼接**，JDK 8及之前编译器会转换为StringBuilder链式调用：

```java
String s = "Hello" + name + "!";
// 编译后等价于
String s = new StringBuilder().append("Hello").append(name).append("!").toString();
```

**JDK 9之后**引入了invokedynamic指令来处理字符串拼接，运行时由JVM决定最优策略，性能更好且更灵活。

**但循环内拼接编译器优化不了**：

```java
String result = "";
for (int i = 0; i < 10000; i++) {
    result += i;  // 每次循环都创建新的StringBuilder和String对象
}
```

每次迭代都会创建`StringBuilder`、拼接、调用`toString`生成新`String`，效率很低。这种场景必须手动在循环外创建`StringBuilder`：

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append(i);
}
String result = sb.toString();
```

简单说，单行拼接交给编译器优化即可，循环拼接必须手动用StringBuilder。

---

### · StringBuilder扩容是原容量乘2再加2，为什么要加2？

加2主要是为了处理边界情况。

当容量为0时，乘2还是0，加2保证至少能扩到2。虽然默认构造器初始容量是16，但StringBuilder有个接受String参数的构造器，如果传入空字符串，初始容量就是0+16=16没问题；但如果直接调用内部方法或通过某些路径导致容量为0，纯乘2就卡住了。

另外加2还能为小字符串多留一点余量，减少频繁扩容的可能。比如容量1扩容后是4而不是2，容量2扩容后是6而不是4。

不过说实话，这个设计更多是历史惯例。JDK早期版本就这么定了，后续版本保持兼容没改。加2比加1稍微宽裕一点，比加更大的数又不会太浪费，算是个折中选择。

> [!quote] 参考
> [Java的StringBuilder是怎么实现的？](https://www.mianshiya.com/question/1780933294532096002)

---
### · StringBuffer 的 `synchronized` 加在哪了？

StringBuffer 的 `synchronized` 修饰符加在**所有公共方法**上（例如 `append()`、`insert()`、`delete()` 等）。  

具体来说，StringBuffer 的每个对外暴露的操作方法都通过 `synchronized` 关键字实现了线程安全，例如：  

```java
public synchronized StringBuffer append(String str) {
    // ...
}
```  

这种设计保证了在多线程环境下，对 StringBuffer 对象的修改操作是原子的，避免了并发修改导致的数据不一致问题。

---
### · String 的 intern 方法是干什么的？什么场景下会用？

`String.intern()` 是一个将字符串放入**字符串常量池**并返回池中引用的方法。

```java
String s1 = new String("hello");  // 堆中创建新对象
String s2 = s1.intern();          // 返回常量池中的 "hello"
String s3 = "hello";              // 常量池中的 "hello"

System.out.println(s1 == s3);     // false，s1 在堆中
System.out.println(s2 == s3);     // true，都指向常量池
```

调用 `intern()` 时，JVM 会检查常量池中是否已有内容相同的字符串：有则返回池中引用，没有则将该字符串加入池中再返回。

**1. 大量重复字符串的内存优化**

比如解析日志或 CSV 文件时，某些字段值会反复出现：

```java
// 假设解析百万行数据，status 只有 "SUCCESS"、"FAILED" 等几种值
String status = parseStatus(line).intern();
```

这样所有相同状态共享一个对象，而不是创建百万个重复的 String 实例。

**2. 需要用 == 快速比较的场景**

`intern()` 后可以用 `==` 代替 `equals()`，性能更好：

```java
String key = inputKey.intern();
if (key == "EXPECTED_VALUE") { ... }
```

实际上**很少需要手动调用** `intern()`，原因是JDK 7+ 将字符串常量池移到了堆中，GC 可以回收。过度使用反而可能导致常量池膨胀、哈希冲突增加，编译期字面量和 `+` 拼接的常量已经自动 `intern`。

---

### · Java中包装类型和基本对象类型的区别是什么？

基本类型是直接存储值的简单数据，包括`byte`、`short`、`int`、`long`、`float`、`double`、`char`、`boolean`。包装类型是对应的对象形式，分别是`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean`。

**存储位置不同**。基本类型的局部变量存在**栈**上，作为字段时随对象存在堆中。包装类型是对象，实例在**堆**上，变量持有的是**引用**。

**默认值不同**。基本类型作为成员变量默认值是0、0.0或false。包装类型默认值是null，使用前必须判空，否则拆箱时会抛`NullPointerException`。

**能否用于泛型**。泛型只能使用包装类型，`List<int>`不合法，必须写`List<Integer>`。

**性能差异**。基本类型直接运算，包装类型涉及对象创建、内存分配、装箱拆箱开销，性能敏感场景优先用基本类型。

**相等性比较**。基本类型用`==`比较值本身，包装类型用`==`比较的是引用，比较值应该用`equals`。但`Integer`在-128到127范围内有缓存，`==`比较可能返回true，这容易踩坑：

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b);  // true，缓存范围内

Integer c = 128;
Integer d = 128;
System.out.println(c == d);  // false，超出缓存
```

选择原则：性能敏感、确定不为null时用基本类型；需要表示缺失值、用于集合泛型时用包装类型。

所有包装类都是不可变类，它们都声明为`final`防止继承，内部存储值的字段也是`final`的，没有提供任何修改方法。

```java
public final class Integer extends Number {
    private final int value;
    // 没有setValue方法
}
```

设计成不可变主要有三个原因。一是安全性，包装类经常作为`HashMap`的key或在多线程间传递，不可变保证了`hashCode`稳定和线程安全。二是支持缓存机制，`Integer`缓存-128到127的实例供复用，如果可变就会互相影响。三是与基本类型语义一致，`int a = 1`修改a实际上是重新赋值而不是修改原来的1，包装类型保持同样的行为。

所以对包装类型的任何"修改"操作实际上都是创建新对象：

```java
Integer a = 100;
a += 1;  // 实际上是 a = Integer.valueOf(a.intValue() + 1)
```

---

### · 为何要有包装类型？

因为Java泛型和集合框架只能操作对象，无法直接使用基本类型。`List<int>`是不合法的，必须写成`List<Integer>`。没有包装类型，基本类型就无法参与泛型、集合、反射这些面向对象的机制。

另外包装类型可以表示null，这在很多场景下很重要。比如数据库查询结果可能为空、HTTP参数可能缺失，用Integer可以区分"值是0"还是"没有值"，用int就无法表达这种语义。

包装类还提供了大量实用方法和常量，比如`Integer.parseInt()`、`Integer.MAX_VALUE`、`Double.isNaN()`等，这些如果没有包装类就没地方放。

---

### · 自动装箱拆箱的实现

自动装箱拆箱是编译器层面的语法糖，编译时会自动插入转换方法调用。

装箱时编译器插入`valueOf`方法：

```java
Integer a = 100;
// 编译后等价于
Integer a = Integer.valueOf(100);
```

拆箱时编译器插入`xxxValue`方法：

```java
int b = a;
// 编译后等价于
int b = a.intValue();
```

valueOf方法内部有缓存机制，Integer默认缓存-128到127：

```java
public static Integer valueOf(int i) {
    if (i >= -128 && i <= 127) {
        return IntegerCache.cache[i + 128];
    }
    return new Integer(i);
}
```

这就解释了为什么范围内的`Integer`用`==`比较返回true，超出范围返回false——缓存范围内返回的是同一个对象。

需要注意的坑：包装类型为null时拆箱会抛NPE。

```java
Integer a = null;
int b = a;  // NullPointerException，因为实际调用的是a.intValue()
```

---

### · 包装类缓存机制详解

Integer缓存默认范围是-128到127，这个范围覆盖了日常使用最频繁的小整数。JVM启动时就创建好这些对象放在IntegerCache数组中，valueOf方法直接返回缓存对象，避免重复创建。

```java
private static class IntegerCache {
    static final int low = -128;
    static final int high;  // 默认127，可配置
    static final Integer[] cache;
    
    static {
        int h = 127;
        // 可通过JVM参数调整上限
        String value = VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (value != null) {
            h = Math.max(Integer.parseInt(value), 127);
        }
        high = h;
        cache = new Integer[(high - low) + 1];
        for (int i = 0; i < cache.length; i++) {
            cache[i] = new Integer(low + i);
        }
    }
}
```

可以通过JVM参数`-XX:AutoBoxCacheMax=1000`调大上限，适合业务中大量使用某个范围整数的场景。下限-128是固定的，不能调整。

其他包装类型也有缓存，但范围固定不可配置：Byte、Short、Long缓存-128到127，Character缓存0到127，Boolean缓存TRUE和FALSE两个实例。Float和Double没有缓存，因为浮点数范围内的值太多，缓存意义不大。

---
### · 基本类型和包装类型都各占几个字节？

|类型|字节数|位数|范围|
|---|---|---|---|
|byte|1|8|-128 ~ 127|
|short|2|16|-32768 ~ 32767|
|int|4|32|约±21亿|
|long|8|64|约±922亿亿|
|float|4|32|约±3.4×10³⁸|
|double|8|64|约±1.8×10³⁰⁸|
|char|2|16|0 ~ 65535|
|boolean|1*|-|true/false|

boolean比较特殊，JVM规范没有严格规定大小。单个boolean通常当作int处理占4字节，boolean数组中每个元素占1字节。

包装类型作为对象，除了存储值本身还有对象头开销。以64位JVM开启压缩指针（默认开启）为例：

|类型|对象头|数据|对齐填充|总计|
|---|---|---|---|---|
|Byte|12|1|3|16|
|Short|12|2|2|16|
|Integer|12|4|0|16|
|Long|12|8|4|24|
|Float|12|4|0|16|
|Double|12|8|4|24|
|Character|12|2|2|16|
|Boolean|12|1|3|16|

对象头12字节包含Mark Word（8字节）和类型指针（压缩后4字节）。对象大小必须是8的倍数，不足的部分用对齐填充补齐。

对比一下：int占4字节，Integer占16字节，是4倍。long占8字节，Long占24字节，是3倍。这就是为什么性能敏感场景要优先用基本类型。

---
### · Integer的缓存池是在什么时候初始化的？会不会有并发问题？

`IntegerCache` 是 `Integer` 的静态内部类，在类加载阶段就初始化好了。JVM 保证类加载是线程安全的，所以不存在并发问题。缓存数组一旦初始化完成就不会再变，所有线程共享读取，不需要加锁。

超出缓存范围时，`Integer.valueOf(a)`每次都直接new一个新对象，不会放入缓存池。

```java
public static Integer valueOf(int i) {
    if (i >= -128 && i <= 127) {
        return IntegerCache.cache[i + 128];  // 缓存范围内，返回缓存对象
    }
    return new Integer(i);  // 超出范围，每次new新对象
}
```

所以这个代码：

```java
Integer a = 129;  // new Integer(129)
Integer b = 129;  // new Integer(129)，另一个新对象
System.out.println(a == b);  // false，两个不同的对象
```

缓存池是固定大小的数组，在JVM启动时就初始化好了，运行时不会动态扩展。如果需要扩大缓存范围，只能通过JVM参数`-XX:AutoBoxCacheMax=256`在启动前配置。

---
### · 为什么说在循环里面频繁拆装箱性能很差？差到什么程度？

循环中频繁装箱拆箱性能差是因为每次装箱都可能创建新对象。虽然`Integer`有-128到127的缓存，但超出这个范围每次`Integer.valueOf()`都会`new`一个新`Integer`对象。

以图中代码为例，循环1000万次，每次`sum += i`实际上是：

```java
sum = Integer.valueOf(sum.intValue() + i);
```

如果`sum`的值超过127（几乎立刻就会超过），每次循环都要在堆上创建一个新`Integer`对象，然后旧对象变成垃圾等待GC回收。1000万次循环就是近1000万个临时对象，带来的开销包括：内存分配、对象初始化、GC压力。

性能差距大概在**3到5倍**左右，具体取决于JVM版本和GC策略。数据量越大、GC触发越频繁，差距越明显。

解决方案很简单，循环内部用基本类型：

```java
long sum = 0L;  // 用基本类型
for (int i = 0; i < 1000000; i++) {
    sum += i;
}
```

---
### · Integer 和 int 在方法参数上有什么区别？传参的时候会发生什么？

`int`作为参数是值传递，方法内修改不影响外部。`Integer`作为参数传递的是引用的副本，但由于`Integer`不可变，方法内任何"修改"都是创建新对象并让局部引用指向它，同样不影响外部。

---
### · Long的缓存范围能像Integer一样调整吗？

不能。Long的缓存范围固定是-128到127，没有提供JVM参数来调整。

```java
private static class LongCache {
    static final Long[] cache = new Long[256];
    
    static {
        for (int i = 0; i < 256; i++) {
            cache[i] = new Long(i - 128);
        }
    }
}
```

只有Integer提供了`-XX:AutoBoxCacheMax`参数可以调整上限，其他包装类型的缓存范围都是写死的：Byte、Short、Long固定-128到127，Character固定0到127，Boolean只缓存TRUE和FALSE两个实例，Float和Double没有缓存。

为什么只有Integer可配置？可能是因为int是最常用的整数类型，实际业务中经常出现超过127但重复率很高的场景，比如状态码、年龄、数量等。而long通常用于id、时间戳这种值域很大且不重复的场景，扩大缓存意义不大。

---

### · 接口和抽象类有什么区别

接口和抽象类在设计动机上有所不同。

接口的设计是**自上而下**的。我们知晓某一行为，于是基于这些行为约束定义了接口，需要这些行为的类来实现它。

抽象类的设计是**自下而上**的。我们写了很多类，发现它们之间有共性，很多代码可以复用，于是将公共逻辑封装成抽象类，减少冗余。

所谓自上而下是先约定接口再实现，自下而上是先有具体类再抽象出父类。可能和学校教的不太一样，但实战中很多抽象类都是重构的产物。

其他区别：

**方法实现**：接口中的方法默认是`public abstract`，Java 8之后可以有`default`方法和`static`方法。抽象类可以包含`abstract`方法和具体方法，允许子类继承并复用。

**构造函数和成员变量**：接口不能有构造函数，成员变量默认是`public static final`常量。抽象类可以有构造函数，成员变量可以有不同访问修饰符且不必是常量。

**多继承**：抽象类只能单继承，接口可以多实现。

---
### · 抽象类能不能有构造函数？有何作用？

可以有。抽象类的构造函数用于初始化抽象类中定义的字段，供子类构造时调用。

虽然抽象类不能直接实例化，但子类实例化时必须先调用父类构造器完成父类部分的初始化。如果抽象类没有无参构造器，子类构造器必须显式调用`super(...)`。

这也体现了抽象类和接口的区别之一：抽象类可以持有状态并通过构造器初始化，接口不能。

---
### · 接口里的变量为何默认是`public static final`？

因为接口的定位是定义行为契约，不是持有状态。

**`public`**：接口是公开的契约，所有实现类和使用方都需要访问，私有变量没有意义。

**`static`**：接口不能实例化，没有实例就不可能有实例变量，只能是类级别的静态变量。

**`final`**：如果变量可变，不同实现类可能修改它导致混乱。既然接口定义的是契约，契约中的常量就应该是不可变的。

---
### · 一个类可以同时继承抽象类和实现接口吗？

可以。Java 允许一个类继承一个抽象类的同时实现多个接口。这也是 Java 解决单继承限制的常用手段，核心代码复用放抽象类里，额外的能力通过接口来补充。

Java集合框架中很多类都是这样设计的，比如ArrayList继承AbstractList抽象类，同时实现List、RandomAccess、Serializable等接口。

---

### · Java 中 `hashCode` 和 `equals` 方法是什么？它们与 == 操作符有什么区别？

**`==`操作符**比较的是内存地址，判断两个引用是否指向同一个对象。

```java
String a = new String("hello");
String b = new String("hello");
System.out.println(a == b);  // false，不是同一个对象
```

**equals方法**默认行为和`==`一样，但设计意图是让子类重写来定义"逻辑相等"。`String`重写了`equals`来比较内容：

```java
System.out.println(a.equals(b));  // true，内容相同
```

**`hashCode方法`** 返回对象的哈希码，用于`HashMap`、`HashSet`等哈希结构快速定位。默认实现基于内存地址生成，重写`equals`时必须同时重写`hashCode`。

三者的关系：

- `a == b`为true，则`a.equals(b)`必为true，`hashCode`必相同
- `a.equals(b)`为true，`hashCode`必须相同（约定）
- `hashCode`相同，`equals`不一定为true（哈希冲突）

为什么重写`equals`必须重写`hashCode`？`HashMap`先用`hashCode`定位桶，再用`equals`确认。如果两个对象`equals`为true但`hashCode`不同，HashMap会认为它们在不同的桶里，导致逻辑错误：

```java
class User {
    String name;
    
    @Override
    public boolean equals(Object o) {
        return name.equals(((User) o).name);
    }
    
    // 没重写hashCode
}

User u1 = new User("张三");
User u2 = new User("张三");

Set<User> set = new HashSet<>();
set.add(u1);
set.contains(u2);  // 可能返回false，因为hashCode不同落在不同桶
```

---
### · 重写 equals 的五大原则

重写equals必须满足五个原则：

**自反性**：对象必须等于自身，`x.equals(x)`永远返回true。

**对称性**：如果`x.equals(y)`为true，那么`y.equals(x)`也必须为true。

**传递性**：如果`x.equals(y)`为true且`y.equals(z)`为true，那么`x.equals(z)`也必须为true。

**一致性**：只要对象状态不变，多次调用`x.equals(y)`的结果必须一致。

**非空性**：任何非null对象`x.equals(null)`必须返回false。

标准写法：

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;                          // 自反性+性能优化
    if (o == null || getClass() != o.getClass()) return false;  // 非空性+类型检查
    User user = (User) o;
    return age == user.age && Objects.equals(name, user.name);  // 字段比较
}
```

常见错误是对称性问题，比如父类和子类互相equals时行为不一致。用`getClass()`而非`instanceof`可以避免这个问题，但也牺牲了多态性。具体选择取决于业务需求。

---

### · hashCode 的默认实现

Object的`hashCode`是`native`方法，OpenJDK 8默认使用Xorshift随机数算法，首次调用时生成随机值并缓存到对象头的Mark Word中。

> 注意：默认实现跟内存地址没有必然联系，虽然很多文章这么说，但HotSpot实际有6种hashCode生成策略，可通过`-XX:hashCode`参数切换。

---

### · String 重写 hashCode 是怎么实现的？

String的`hashCode`基于内容计算，使用经典的31系数多项式哈希：

```java
public int hashCode() {
    int h = hash;  // 缓存值，默认0
    if (h == 0 && value.length > 0) {
        char[] val = value;
        for (int i = 0; i < val.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;  // 缓存结果
    }
    return h;
}
```

计算公式是：`s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]`

比如"abc"的`hashCode`：`'a'*31² + 'b'*31 + 'c'` = `97*961 + 98*31 + 99` = `96354`

**为什么选31？**

一是31是奇素数，乘以素数能让哈希值分布更均匀，减少冲突。二是31乘法可以被JVM优化为位运算：`31 * h` 等价于 `(h << 5) - h`，性能更好。三是31不太大也不太小，计算结果不容易溢出且离散性好。

**缓存机制**：String不可变，hashCode首次计算后缓存在hash字段中，后续调用直接返回，不重复计算。

---
### · 怎么正确重写hashCode？

基本原则是`equals`中用到的字段都要参与`hashCode`计算，保证`equals`相等的对象`hashCode`一定相同。

**标准写法**，使用`Objects.hash()`：

```java
@Override
public int hashCode() {
    return Objects.hash(name, age, email);
}
```

简单方便，内部使用31系数计算，适合大多数场景。

**手动实现**，性能更好：

```java
@Override
public int hashCode() {
    int result = 17;  // 非零初始值
    result = 31 * result + (name == null ? 0 : name.hashCode());
    result = 31 * result + age;
    result = 31 * result + (email == null ? 0 : email.hashCode());
    return result;
}
```

实际开发中直接用IDE生成或Lombok的`@EqualsAndHashCode`注解最省事。

---

### · HashMap 的 key 用可变对象有什么风险？

可变对象作为key，如果修改了参与`hashCode`计算的字段，会导致这个键值对"丢失"。

```java
class User {
    String name;
    
    public User(String name) {
        this.name = name;
    }
    
    @Override
    public int hashCode() {
        return name.hashCode();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        return name.equals(((User) o).name);
    }
}

Map<User, String> map = new HashMap<>();
User user = new User("张三");
map.put(user, "数据");

System.out.println(map.get(user));  // "数据"

user.name = "李四";  // 修改了key

System.out.println(map.get(user));  // null，找不到了
```

原因是`put`时按"张三"的`hashCode`放到某个桶里，修改后`get`时按"李四"的`hashCode`去另一个桶找，自然找不到。更糟的是这个键值对还占着内存，却无法访问也无法删除，造成内存泄漏。

所以`HashMap`的`key`应该用不可变对象，比如`String`、`Integer`、或者自定义的不可变类。如果必须用可变对象，至少保证放入`Map`后不再修改参与`hashCode`计算的字段。

---
