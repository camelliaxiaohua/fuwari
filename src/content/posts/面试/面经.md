---
title: 面经
category: 面试
tags:
  - 面试
published: 2026-01-29
updated: 2026-01-29
draft: true
---
---
## 1. Java基础

### · 序列化和反序列化是什么？

**序列化（Serialization）** 是将Java对象转换为字节序列（字节流）的过程，这样对象就可以被保存到文件、数据库中，或者通过网络传输。**反序列化（Deserialization）** 则是相反的过程，将字节序列（字节流）恢复为Java对象。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260129220900991.png" alt="image-20260129220900991" style="zoom: 33%;" />

1. **如何实现序列化？**

类必须实现`Serializable`接口，这个相当于一个许可证，没它 JDK 序列化机制不会让你序列化。

> 这接口是个空接口，一行代码都没有，纯粹就是个标记。JDK 序列化源码里有这么一段逻辑：除了 String、数组和枚举这几个特殊类型，其他对象要序列化必须实现 Serializable，否则直接抛 `NotSerializableException`。

2. **如何避免某些属性序列化？**

`transient` 关键字修饰的字段不会被序列化，序列化的时候会自动跳过。

> `transient` 字段在反序列化后，不是“保留旧值”，而是被赋成“类型的默认值”。

3. **如何保证序列化够稳？**

显式定义 `serialVersionUID`，相当于给类打个版本戳，防止改了类结构后反复序列化旧数据时报错。

> 这就等于你在说：“不管我内部怎么小改，只要我没手动改 `serialVersionUID`，就请你当成是同一个版本。”

> [!quote] 详情参考
> [[如何保证序列化够稳？]]

---

### · 对象为什么不能直接传输？

对象在内存中包含 对象数据（字段值）、内存地址引用、方法指针、虚拟方法表（vtable）等元数据，这些信息在不同的JVM进程中完全不同，无法直接复制。

无论是网络传输还是文件存储，底层只能处理连续的字节序列（byte stream），不理解Java对象的结构。

---

### · 静态变量参与序列化吗？

静态变量不参与序列化。

静态变量属于**类本身**，而不是对象实例。序列化是保存**对象的状态**，静态变量不是对象状态的一部分。反序列化后，静态变量的值**完全取决于当前JVM中类的静态变量值**，与序列化时的值无关。

---

### · 如果父类没有实现`Serializable`，子类实现了，序列化子类对象时父类对象会如何？

父类未实现 `Serializable` 时，序列化会"跳过"父类字段，反序列化时通过调用父类无参构造方法来初始化父类部分，所以父类字段会恢复为初始值而非序列化时的值。**如果父类没有无参构造方法，反序列化会直接失败，抛出 `InvalidClassException` 异常**。

---

### · JDK 序列化的问题

JDK 自带的序列化虽然用起来简单，但生产环境很少直接用，主要有这几个硬伤：

1. **性能差**：序列化后的字节流体积大，序列化/反序列化速度慢
2. **跨语言不友好**：只有 Java 能读懂，无法与 Go、Python 等语言直接互通
3. **安全风险**：存在反序列化漏洞，可能被恶意利用执行任意代码

所以实际项目中，RPC 框架一般用 Protobuf、Hessian、Kryo 这类专门的序列化框架，性能更好、体积更小。JSON 序列化虽然性能一般，但可读性好，在 HTTP API 场景中使用广泛。

|序列化方式|优点|缺点|典型场景|
|---|---|---|---|
|JDK 原生|使用简单|性能差、体积大、有安全风险|小项目、临时方案|
|JSON|可读性好、跨语言|性能一般、体积较大|HTTP API、配置文件|
|Protobuf|高性能、体积小|需要定义 .proto 文件|gRPC、高性能 RPC|
|Hessian|性能较好、使用简单|跨语言支持有限|Dubbo 默认序列化|
|Kryo|高性能、体积小|仅支持 Java|游戏服务器、缓存|

---

### · 为什么说反序列化是 Java 安全漏洞的重灾区？

反序列化会触发对象的构造过程，如果攻击者构造恶意的字节流，就能让某些类的特定方法被执行，从而造成远程代码执行（RCE）。

典型案例是利用 Apache Commons Collections、Fastjson 等库中的 **gadget chain**（利用链）。攻击者只需找到一条从反序列化入口通往危险方法（如 `Runtime.exec()`）的调用链，就能在服务器上执行任意命令，比如反弹 shell、读取敏感文件等。

**防御手段：**

1. **及时升级**：修复 Commons Collections、Fastjson 等已知存在漏洞的依赖库
2. **白名单机制**：配置反序列化白名单，只允许可信类进行反序列化
3. **替代方案**：使用 JSON、Protobuf 等更安全的序列化方式替代 Java 原生序列化
4. **网络隔离**：不直接暴露反序列化接口到公网

---
### · Java 中 Exception 和 Error 有什么区别?

`Exception` 和 `Error` 都是 `Throwable` 的子类，但它们的用途和处理方式完全不同。

> 只有继承了 `Throwable` 的对象才能被 `throw` 和 `catch`。

**Exception（异常）**

- **可预期的问题**，程序可以捕获并处理；
- 分为受检异常（`Checked Exception`）和非受检异常（`Unchecked Exception`）；
- 应该被 `try-catch` 捕获或通过 `throws` 声明。

> [!tip] 
> `Checked Exception`: 继承自 `Exception` 但不继承 `RuntimeException`，编译时必须显式处理，要么 `try-catch` 要么 `throws` 声明抛出，比如 `IOException`、`SQLException`。
> 
> `Unchecked Exception`: 继承自 `RuntimeException`，不需要显式捕获，运行时才抛出，比如 `NullPointerException`、`IndexOutOfBoundsException`。

**Error（错误）**

- **严重的系统级问题**，程序通常无法处理；
- 都是非受检的（继承自 `Error`）；
- 不应该被捕获，程序应该终止。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260130144522567.png" alt="image-20260130144522567" style="zoom: 33%;" />

---

### · 什么是Java多态特性？

多态（Polymorphism）是面向对象编程的三大特性之一（封装、继承、多态），指的是**同一个方法调用，在不同对象上会有不同的表现形式**。

> 简单来说：父类引用指向子类对象，调用方法时会执行子类的实现。

要实现多态，必须满足以下条件：

1. **继承关系**：子类继承父类或实现接口
	
2. **方法重写**：子类重写父类的方法
	
3. **父类引用指向子类对象**：向上转型

---

### · 编译时多态和运行时多态

**编译时多态（静态多态）**

通过**方法重载（Overload）** 实现，在编译阶段就能确定调用哪个方法。同一个类中，方法名相同，参数列表不同（参数个数、类型或顺序不同），编译器根据方法签名在编译时就能确定调用哪个方法，也叫**静态绑定**或**早期绑定**。

**运行时多态（动态多态）**

通过**方法重写（Override）** 实现，在运行时才能确定调用哪个方法。父类引用指向子类对象，子类重写父类的方法。运行时根据对象的实际类型决定调用哪个方法，也叫**动态绑定**或**晚期绑定**。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260130150850155.png" alt="image-20260130150850155" style="zoom: 50%;" />

---
### · 虚方法表的底层原理（简要概括）

虚方法表是 JVM 为每个类构建的方法地址索引表，用于实现运行时多态。当子类重写父类方法时，会在虚方法表的相同索引位置替换为自己的方法地址。多态调用时，JVM 根据对象的实际类型找到对应的虚方法表，通过索引直接定位方法地址并调用，实现 O(1) 的快速查找，这就是 Java 多态"运行时动态绑定"的底层实现机制。

> [!quote] 详情参考
> [[虚方法表的底层原理]]

---

### · Java中参数传递是值传递还是引用传递？

**Java 中只有值传递（Pass by Value），没有引用传递。**

- **值传递**：传递的是变量值的副本，修改副本不影响原变量。
- **引用传递**：传递的是变量本身的引用的副本（**内存地址值**），修改会影响原变量。

> **Java 的规则**：无论基本类型还是对象类型，传递的都是值的副本。

---
### · 基本类型与引用类型的区别？

**基本类型**包括 `byte`、`short`、`int`、`long`、`float`、`double`、`char`、`boolean` 共 8 种。作为局部变量时，基本类型的值直接存储在栈内存中；作为成员变量时，存储在堆内存的对象中。方法传参时传递的是值的副本，方法内的修改不影响原始变量。

**引用类型**包括类、接口、数组等。引用类型的变量存储的是对象在堆内存中的地址（引用值）。方法传参时传递的是地址值的副本，因此方法内可以通过这个副本引用修改对象的内容，但无法改变原引用变量指向的对象。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260201145710540.png" alt="image-20260201145710540" style="zoom: 50%;" />


> [!quote] 详情参考
> [[基本类型与引用类型在 JVM 存储位置]]

---

### · `String` 作为参数传递后在方法里修改了但为什么原来的变量没变？

`String` 是不可变类，方法里对 `String` 做任何拼接或替换操作，实际上是创建了一个新的 `String` 对象，然后让方法内的局部引用指向这个新对象。原来的引用还是指向老对象，压根没动过。这不是传引用还是传值的问题，而是 `String` 本身的不可变性决定的。


> [!quote] 详情参考
> [[Java中的不可变类]]

---
### · 为何Java不支持多重继承？

