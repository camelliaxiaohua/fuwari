---
title: 面经
category: 面试
tags:
  - 面试
published: 2026-01-29
updated: 2026-01-29
draft: true
---
---
## 1. Java基础

### · 序列化和反序列化是什么？

**序列化（Serialization）** 是将Java对象转换为字节序列（字节流）的过程，这样对象就可以被保存到文件、数据库中，或者通过网络传输。**反序列化（Deserialization）** 则是相反的过程，将字节序列（字节流）恢复为Java对象。

<img src="https://camelliaxiaohua-1313958787.cos.ap-shanghai.myqcloud.com/markdown/image-20260129220900991.png" alt="image-20260129220900991" style="zoom: 33%;" />

1. **如何实现序列化？**

类必须实现`Serializable`接口，这个相当于一个许可证，没它 JDK 序列化机制不会让你序列化。

> 这接口是个空接口，一行代码都没有，纯粹就是个标记。JDK 序列化源码里有这么一段逻辑：除了 String、数组和枚举这几个特殊类型，其他对象要序列化必须实现 Serializable，否则直接抛 `NotSerializableException`。

2. **如何避免某些属性序列化？**

`transient` 关键字修饰的字段不会被序列化，序列化的时候会自动跳过。

> `transient` 字段在反序列化后，不是“保留旧值”，而是被赋成“类型的默认值”。

3. **如何保证序列化够稳？**

显式定义 `serialVersionUID`，相当于给类打个版本戳，防止改了类结构后反复序列化旧数据时报错。

> 这就等于你在说：“不管我内部怎么小改，只要我没手动改 `serialVersionUID`，就请你当成是同一个版本。”

> [!quote] 引用
> [[如何保证序列化够稳？]]

---

### · 对象为什么不能直接传输？

对象在内存中包含 对象数据（字段值）、内存地址引用、方法指针、虚拟方法表（vtable）等元数据，这些信息在不同的JVM进程中完全不同，无法直接复制。

无论是网络传输还是文件存储，底层只能处理连续的字节序列（byte stream），不理解Java对象的结构。

---

### · 静态变量参与序列化吗？

静态变量不参与序列化。

静态变量属于**类本身**，而不是对象实例。序列化是保存**对象的状态**，静态变量不是对象状态的一部分。反序列化后，静态变量的值**完全取决于当前JVM中类的静态变量值**，与序列化时的值无关。

---

### · 如果父类没有实现`Serializable`，子类实现了，序列化子类对象时父类对象会如何？

父类未实现 `Serializable` 时，序列化会"跳过"父类字段，反序列化时通过调用父类无参构造方法来初始化父类部分，所以父类字段会恢复为初始值而非序列化时的值。**如果父类没有无参构造方法，反序列化会直接失败，抛出 `InvalidClassException` 异常**。

---

### · JDK 序列化的问题

JDK 自带的序列化虽然用起来简单，但生产环境很少直接用，主要有这几个硬伤：

1. **性能差**：序列化后的字节流体积大，序列化/反序列化速度慢
2. **跨语言不友好**：只有 Java 能读懂，无法与 Go、Python 等语言直接互通
3. **安全风险**：存在反序列化漏洞，可能被恶意利用执行任意代码

所以实际项目中，RPC 框架一般用 Protobuf、Hessian、Kryo 这类专门的序列化框架，性能更好、体积更小。JSON 序列化虽然性能一般，但可读性好，在 HTTP API 场景中使用广泛。

|序列化方式|优点|缺点|典型场景|
|---|---|---|---|
|JDK 原生|使用简单|性能差、体积大、有安全风险|小项目、临时方案|
|JSON|可读性好、跨语言|性能一般、体积较大|HTTP API、配置文件|
|Protobuf|高性能、体积小|需要定义 .proto 文件|gRPC、高性能 RPC|
|Hessian|性能较好、使用简单|跨语言支持有限|Dubbo 默认序列化|
|Kryo|高性能、体积小|仅支持 Java|游戏服务器、缓存|

---

### · 为什么说反序列化是 Java 安全漏洞的重灾区？

反序列化会触发对象的构造过程，如果攻击者构造恶意的字节流，就能让某些类的特定方法被执行，从而造成远程代码执行（RCE）。

典型案例是利用 Apache Commons Collections、Fastjson 等库中的 **gadget chain**（利用链）。攻击者只需找到一条从反序列化入口通往危险方法（如 `Runtime.exec()`）的调用链，就能在服务器上执行任意命令，比如反弹 shell、读取敏感文件等。

**防御手段：**

1. **及时升级**：修复 Commons Collections、Fastjson 等已知存在漏洞的依赖库
2. **白名单机制**：配置反序列化白名单，只允许可信类进行反序列化
3. **替代方案**：使用 JSON、Protobuf 等更安全的序列化方式替代 Java 原生序列化
4. **网络隔离**：不直接暴露反序列化接口到公网

---
